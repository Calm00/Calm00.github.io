{"meta":{"title":"Honahec","subtitle":"Honahec","description":"","author":"Honahec","url":"http://www.honahec.com","root":"/"},"pages":[{"title":"404","date":"2021-06-25T04:53:26.000Z","updated":"2021-06-25T04:53:44.911Z","comments":true,"path":"404/index.html","permalink":"http://www.honahec.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-09-19T06:52:09.731Z","updated":"2021-09-19T06:52:09.731Z","comments":true,"path":"about/index.html","permalink":"http://www.honahec.com/about/index.html","excerpt":"","text":"Hello 大家好啊我是Honahec，一个九年级蒟蒻 目前这个博客仍在建设中，如果您有任何想法都可以在此留言或者添加我的QQ(2411482814)，会采纳部分建议 由于学业为重，回复和更新可能不及时，见谅 我都会些什么？正在打oi（刚打完2021csp-s初赛，坐标SD，很慌 会一点点C++ 会一点点虚幻4 会一点点视频制作 如果您也有这方面的兴趣，欢迎添加我的QQ讨论"},{"title":"archives","date":"2021-09-16T11:55:31.000Z","updated":"2021-09-16T11:55:31.397Z","comments":true,"path":"archives/index.html","permalink":"http://www.honahec.com/archives/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-06-25T15:34:43.000Z","updated":"2021-09-12T06:52:41.044Z","comments":true,"path":"guestbook/index.html","permalink":"http://www.honahec.com/guestbook/index.html","excerpt":"","text":"欢迎来到我的博客！ 欢迎在这里留言！任何问题都可以在这里留言，我会及时回复的，添加email可以获得更快的回复速度。您也可以选择添加我的QQ并备注此网站。"},{"title":"分类","date":"2021-09-17T13:03:50.000Z","updated":"2021-09-19T06:53:18.505Z","comments":true,"path":"categories/index.html","permalink":"http://www.honahec.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-09-19T07:10:49.496Z","updated":"2021-09-19T07:10:49.496Z","comments":true,"path":"links/index.html","permalink":"http://www.honahec.com/links/index.html","excerpt":"","text":"欢迎参考下方格式在留言区互换友链哦~ 本站地址：https://honahec.com 头像：https://cdn.jsdelivr.net/gh/Calm00/PicGo/img/avatar.jpg 标题：Honahec的博客 name: Honahec&#39;s blog link: https:&#x2F;&#x2F;honahec.com avatar: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Calm00&#x2F;PicGo&#x2F;img&#x2F;avatar.jpg"},{"title":"标签","date":"2021-09-17T13:03:56.000Z","updated":"2021-09-19T06:53:31.533Z","comments":true,"path":"tags/index.html","permalink":"http://www.honahec.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"csp2021","slug":"csp2021","date":"2021-09-19T11:23:26.000Z","updated":"2021-09-19T11:56:36.967Z","comments":true,"path":"csp2021/","link":"","permalink":"http://www.honahec.com/csp2021/","excerpt":"","text":"day -3快初赛了 刷完这个NOIP2016就都刷完了 83.5还行 （感觉充满了信心） day -1明天就要初赛了 大半夜的我仍在快乐地刷视频qwq day 0（早上的我此刻还没有意识到事情的严重性） 这题怎么一年比一年阴间 什么base64编码，笛卡尔树+Euler序列搞RMQ 最后一题还121行 完全不会呜呜呜 合分56.5，坐标SD，很慌 如果能过会继续在这篇博客更新复赛","categories":[{"name":"比赛","slug":"比赛","permalink":"http://www.honahec.com/categories/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://www.honahec.com/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"ACSL游记","slug":"acsl-you-ji","date":"2021-09-14T11:24:25.000Z","updated":"2021-09-17T12:45:11.477Z","comments":true,"path":"acsl-you-ji/","link":"","permalink":"http://www.honahec.com/acsl-you-ji/","excerpt":"","text":"前不久(其实也没有不久啦本蒟蒻去参加了ACSL Day -5因为没有队友，ASDAN给我随机匹配到了一位大佬qwq 第一个任务是自制游戏并录制vlog！？？我直接人傻了，幸好大佬曾经自己做过一点，我们就很随意地直接使用了那个游戏，然后很随意地制作了一个vlog 主要是5天也做不了游戏啊（可能是我太菜了 游戏源码 vlog： Day 0这比赛为什么要打一天！？？ 上午选择题直接被lisp打蒙了（明明复习过了，但有些根本百度不到呜呜呜 喜提15/20 下午大概看了一眼题目：就这？？ 不得不说，是真的水 t2我直接20分钟切掉 为什么先说t2呢 因为t1有4个点就是调不对，这就是不会打对拍的痛苦吗qwq 喜提16/20 Day 1感觉自己一到最后就总是出一些奇奇怪怪的问题，唉 csp冲冲冲！！！","categories":[{"name":"随便说说","slug":"随便说说","permalink":"http://www.honahec.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://www.honahec.com/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"博客维护动态","slug":"update","date":"2021-09-05T08:43:27.000Z","updated":"2021-09-19T07:10:04.300Z","comments":true,"path":"update/","link":"","permalink":"http://www.honahec.com/update/","excerpt":"","text":"update 2021.9.5数学公式已经维护完毕！！！（起码目前看来是这样的 update 2021.9.12今天瞎搞了一下，优化了体验（但为什么不能页内跳转了qwq，我还没备份…瞎搞有风险，记得备份呜呜呜 update 2021.9.19更换主题为Volantis 添加友链页面（欢迎互换） 添加about页面 添加开往","categories":[{"name":"随便说说","slug":"随便说说","permalink":"http://www.honahec.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"}],"tags":[{"name":"摸鱼","slug":"摸鱼","permalink":"http://www.honahec.com/tags/%E6%91%B8%E9%B1%BC/"}]},{"title":"斜率优化dp","slug":"xie-lv-you-hua-dp","date":"2021-06-25T13:53:49.000Z","updated":"2021-09-17T12:45:11.490Z","comments":true,"path":"xie-lv-you-hua-dp/","link":"","permalink":"http://www.honahec.com/xie-lv-you-hua-dp/","excerpt":"","text":"斜率优化 $ dp $前置知识 名称 定义 凸多边形 所有内角都在 $ (0°,180°) $ 的简单多边形 凸包 在平面上能包含所有给定点的最小凸多边形叫做凸包。 上凸包 凸包中横坐标最小的点到横坐标最大的点的上半部分 下凸包 凸包中横坐标最小的点到横坐标最大的点的下半部分 如下图，蓝色部分是上凸包，橙色部分是下凸包 让我们通过例题来学习斜率优化 $ dp $ 例题[HNOI2008] 玩具装箱题目描述P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。 P 教授有编号为 $ 1 \\cdots n $ 的 $ n $ 件玩具，第件玩具经过压缩后的一维长度为 $ C_i $ 。 为了方便整理，P教授要求： 在一个一维容器中的玩具编号是连续的。 同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $ i $ 件玩具到第 $ j $ 个玩具放到一个容器中，那么容器的长度将为 $ x=j-i+\\sum_{k=i}^{j}C_k $ 。 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $ x $ ，其制作费用为 $ (x-L)^2 $ 。其中 $ L $ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $ L $ 。但他希望所有容器的总费用最小。 输入格式第一行有两个整数，用一个空格隔开，分别代表 $ n $ 和 $ L $ 。 第 $ 2 $ 到 第 $ (n+1) $ 行，每行一个整数，第 $ (i+1) $ 行的整数代表第 $ i $ 件玩具的长度 $ C_i $ 。 输出格式输出一行一个整数，代表所有容器的总费用最小是多少。 数据范围对于全部的测试点， $ 1 \\leq n \\leq 5 \\times 10^4,1 \\leq L \\leq 10^7,1 \\leq C_i \\leq 10^7 $ 基本 $ dp $ 思路设 $ F_i $ 为装前 $ i $ 个玩具的最小费用，则 $ F_i=min_{0\\leq j&lt;i}(F_j+(i-j-1-L+\\sum^{i}_{k=j+1}C_k)^2) $ 其中 $ \\sum^{i}_{k = j+1} C_k $ 可以用前缀和优化掉，变成 $ F_i = min_{0 \\leq j&lt;i}(F_j+(i-j-1-L+sum_i-sum_j)^2) $ 非常好啊， $ O(n^2) $ ，0分到手 怎么办呢？ 处理一下这个 $ dp $ 方程好像不太好处理 首先我们不看这个 $ min $ ，只看 $ F_i=F_j+(i-j-1-L+sum_i-sum_j )^2 $ \\begin{align} 令A=i+sum_i，B&=j+sum_j，C=L+1\\\\ F_j+(A-B-C)^2&=F_j+A^2+(B+C)^2-2A(B+C)\\\\ F_i+2A(B+C)&=F_j+A^2+(B+C)^2\\\\ 令x=B+C，y=F_j&+(B+C)^2，k=2A，b=F_i-A^2\\\\ y&=kx+b \\end{align}想到了什么？ 我们要最小化 $ F_i $ ，那也就是说我们要最小化 $ b $ 对于每一个确定的 $ i $ ， $ k $ 都是确定的 问题转化成了求过 $ (B+C, F_j+(B+C)^2) $ 中任意一点且斜率为k的直线截距的最小值。 补充知识如果你只想知道斜率优化怎么用，那么你可以点此跳过这部分。 我们易可证截距的最小值一定取在下凸包上 证明：假如截距的最小值取在非下凸包上的一个点 $ (x_0,y_0 ) $ ，则有两种情况： （一） 下凸包上有一个点 $ (x_0,y_1) $ 所以过 $ (x_0,y_0) $ 的直线的解析式为 $ y=kx+y_0-kx_0 $ ，过 $ (x_0,y_1) $ 的直线的解析式为 $ y=kx+y_1-kx_0 $ 根据下凸包的定义可得 $ y_0&gt;y_1 $ ，故 $ y_0-kx_0&gt;y_1-kx_1 $ ，矛盾 （二） 下凸包上没有和其横坐标相同的点 根据下凸包的定义，可得下凸包上一定存在两个点 $ (x_1,y_1) $ , $ (x_2,y_2) $ 使得 $ x_1&lt;x_0&lt;x_2 $ 且 $ x_0\\frac{y_1-y_2}{x_1-x_2}+\\frac{x_1 y_2-x_2 y_1}{x_1-x_2}&lt;y_0 $ 我们在经过 $ (x_1,y_1) $ , $ (x_2,y_2) $ 的直线上取一点 $ (x_0,x_0\\frac{y_1-y_2}{x_1-x_2}+\\frac{x_1 y_2-x_2 y_1}{x_1-xx_2}) $ 过 $ (x_0,y_0) $ 的直线解析式为 $ y=kx+y_0-kx_0 $ 过 $ (x_0,x_0\\frac{y_1-y_2}{x_1-x_2}+\\frac{x_1 y_2-x_2 y_1}{x_1-x_2}) $ 的为 $ y=kx+x_0\\frac{y_1-y_2}{x_1-x_2}+\\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0 $ 过 $ (x_1,y_1) $ 的为 $ y=kx+y_1-kx_1 $ 过 $ (x_2,y_2) $ 的为 $ y=kx+y_2-kx_2 $ 由（一）可得 $ y_0-kx_0&gt;x_0\\frac{y_1-y_2}{x_1-x_2}+\\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0 $ \\begin{align} &k>\\frac{y_1-y_2}{x_1-x_2}\\\\ &(x_0\\frac{y_1-y_2}{x_1-x_2}+\\frac{x_1 y_2-x_2 y_1}{x_1-x_2 }-kx_0)-(y_1-kx_1 )\\\\ &=\\frac{x_0 y_1-x_0 y_2+x_1 y_2-x_1 y_1}{x_1-x_2}-k(x_1-x_0)\\\\ &=\\frac{(x_0-x_1)(y_1-y_2)}{x_1-x_2}-k(x_0-x_1)\\\\ &>\\frac{(x_0-x_1 )(y_1-y_2)}{x_1-x_2}-\\frac{(x_0-x_1)(y_1-y_2 )}{x_1-x_2}\\\\ &=0 \\end{align} \\begin{align} &k\\leq\\frac{y_1-y_2}{x_1-x_2}\\\\ &(𝑥_0\\frac{𝑦_1−𝑦_2}{𝑥_1−𝑥_2}+\\frac{𝑥_1 𝑦_2−𝑥_2 𝑦_1}{𝑥_1−𝑥_2}−𝑘𝑥_0 )−(𝑦_2−𝑘𝑥_2 )\\\\ &=\\frac{𝑥_0 𝑦_1−𝑥_0 𝑦_2+𝑥_2 𝑦_2−𝑥_2 𝑦_1}{𝑥_1−𝑥_2}−𝑘(𝑥_2−𝑥_0)\\\\ &=\\frac{(𝑥_0−𝑥_2 )(𝑦_1−𝑦_2 )}{𝑥_1−𝑥_2}−𝑘(𝑥_0−𝑥_2 )\\\\ &≥\\frac{(𝑥_0−𝑥_2 )(𝑦_1−𝑦_2 )}{𝑥_1−𝑥_2}−\\frac{(𝑥_0−𝑥_2 )(𝑦_1−𝑦_2 )}{𝑥_1−𝑥_2}\\\\ &=0 \\end{align} 综上所述，在 $ y_1-kx_1 $ 和 $ y_2-kx_2 $ 中一定存在一个数小于或等于 $ x_0\\frac{y_1-y_2}{x_1-x_2}+\\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0 $ ，又因为 $ y_0-kx_0&gt;x_0\\frac{y_1-y_2}{x_1-x_2}+\\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0 $ ，所以在 $ y_1-kx_1 $ 和 $ y_2-kx_2 $ 中一定存在一个数小于 $ y_0-kx_0 $ ，矛盾。 综上所述，此截距的最小值一定取在下凸包上。 证毕。 回归正题现在我们知道了最优决策点一定在下凸包上 那么我们怎么找最优决策点呢？ 首先我们易得下凸包中所有线的斜率一定是单调递增的 如果存在三个下凸包中的点 $ (x_1,y_1 ) $ ， $ (x_2,y_2 ) $ ， $ (x_3,y_3 ) $ 使得 $ x_1 &lt; x_2 &lt; x_3 $ 且 $ \\frac{y_2-y_1}{x_2-x_1} &gt; \\frac{y_3-y_2}{x_3-x_2} $ ，则 $ y_2 - \\frac{y_3-y_1}{x_3-x_1} x_2 - \\frac{x_3 y_1-x_1 y_3}{x_3-x_1} = \\frac{-x_1 y_2+x_1 y_3+x_2 y_1-x_2 y_3-x_3 y_1+x_3 y_2}{x_3-x_1} $ 又因为 $ x_1 &lt; x_2 &lt; x_3 $ ，所以 $ x_2-x_1 &gt; 0 $ ， $ x_3-x_2 &gt; 0 $ ， $ x_3-x_1 &gt; 0 $ 故 $ (y_2-y_1 )(x_3-x_2 )&gt;(y_3-y_2 )(x_2-x_1 ) $ ，即 $ x_2 y_1-x_3 y_1+x_3 y_2&gt;x_1 y_2-x_1 y_3+x_2 y_3 $ 所以 $ \\frac{-x_1 y_2+x_1 y_3+x_2 y_1-x_2 y_3-x_3 y_1+x_3 y_2}{x_3-x_1}&gt;0 $ ，故 $ y_2&gt;\\frac{y_3-y_1}{x_3-x_1} x_2+\\frac{x_3 y_1-x_1 y_3}{x_3-x_1} $ ，所以 $ (x_2,y_2 ) $ 一定不在下凸包内。 思路很清晰了吧？ 简简单单的代码#include&lt;cstdio&gt; using namespace std; const int N &#x3D; 5e4 + 5; int n, L, C, Qt[N], h &#x3D; 1, t; ll sum[N], f[N], Qx[N], Qy[N]; il ll sq(ll x) &#123;return x * x;&#125; il double sl(ll x1, ll y1, ll x2, ll y2) &#123;return (double) (y1 - y2) &#x2F; (x1 - x2);&#125; int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;L, &amp;C); sum[1] &#x3D; C; f[1] &#x3D; sq(C - L); Qt[++t] &#x3D; 0; Qx[t] &#x3D; L + 1; Qy[t] &#x3D; sq(Qx[t]); Qt[++t] &#x3D; 1; Qx[t] &#x3D; L + 2 + C; Qy[t] &#x3D; f[1] + sq(Qx[t]); for(int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;C); sum[i] &#x3D; sum[i - 1] + C; double slope &#x3D; (i + sum[i]) &lt;&lt; 1; while(h &lt; t &amp;&amp; sl(Qx[h], Qy[h], Qx[h + 1], Qy[h + 1]) &lt; slope) ++h; f[i] &#x3D; f[Qt[h]] + sq(i - Qt[h] - 1 + sum[i] - sum[Qt[h]] - L); ll X &#x3D; i + sum[i] + L + 1, Y &#x3D; f[i] + sq(X); while(h &lt; t &amp;&amp; sl(Qx[t], Qy[t], Qx[t - 1], Qy[t - 1]) &gt;&#x3D; sl(Qx[t], Qy[t], X, Y)) --t; Qt[++t] &#x3D; i; Qx[t] &#x3D; X, Qy[t] &#x3D; Y; &#125; printf(&quot;%lld\\n&quot;, f[n]); return 0; &#125; 问题来了若 $ C_k $ 可以小于0呢？又该怎么做？ 这个我们一眼就能看穿这玩意不满足单调性。 假如说考试的时候你不会证斜率的点或者决策有/没有单调性怎么办？ 有两种方法。第一种是打表，多打几组。 第二种是不管三七二十一直接上不满足单调性时的做法。反正满足单调性的时候不满足单调性时的做法也能用。 不满足单调性的做法： 分治我们用 $ dc(l, r) $ 表示计算 $ [l, r] $ 中的 $ dp_i $ 。 对于左半边，我们先用 $ dc(l, mid) $ 算出 $ [l, mid] $ 中的 $ dp_i $ 。然后我们就知道了所有的决策点，那么就可以建凸包。然后我们用这个凸包去更新 $ [mid, r] $ 中的 $ dp_i $ 。这时的凸包是固定的，所以我们可以把 $ [mid, r] $ 的查询斜率排序，然后用单调队列维护。当然也可以直接在凸包上二分。 对于 $ [mid, r] $ 中的每个 $ dp_i $ ，如果它的最优决策点在 $ [1, mid] $ ，则上一步已经更新完，如果它的最优决策点不在 $ [l, mid] $ 我们也不需要 $ [l, mid] $ 的凸包。所以我们可以直接把左边的凸包抛掉，用 $ dc(mid + 1, r) $ 计算之后的 $ dp_i $ 。 $ T(n)=2T(\\frac{n}{2})+O(n\\log n))=O(n\\log^2n) $ 代码#include &lt;vector&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;algorithm&gt; int n, h[100005], w[100005], pre[100005]; long long dp[100005], sum[100005]; struct Point &#123; long long x, y; int id; Point(long long _x, long long _y, int _id): x(_x), y(_y), id(_id) &#123;&#125; double operator&#x2F; (const Point &amp;p) const &#123; return (double) (y - p.y) &#x2F; (x - p.x); &#125; &#125;; long long min(long long a, long long b) &#123; return a &lt; b ? a : b; &#125; void cdq(int l, int r) &#123; while (l !&#x3D; r) &#123; std::vector&lt;Point&gt; Q, temp; int mid &#x3D; (l + r) &gt;&gt; 1; cdq(l, mid); for (int i &#x3D; l; i &lt;&#x3D; mid; ++i) temp.push_back(Point(h[i], dp[i] + (long long) h[i] * h[i] - sum[i], i)); std::sort(temp.begin(), temp.end(), [] (const Point &amp;p1, const Point &amp;p2) &#123; return p1.x &#x3D;&#x3D; p2.x ? p1.y &lt; p2.y : p1.x &lt; p2.x; &#125;); Q.push_back(temp[0]); int _size &#x3D; 0; for (int i &#x3D; 1; i &lt; (int) temp.size(); ++i) &#123; if (Q[_size].x &#x3D;&#x3D; temp[i].x) continue; while (_size &amp;&amp; Q[_size] &#x2F; Q[_size - 1] &gt; Q[_size] &#x2F; temp[i]) Q.pop_back(), --_size; Q.push_back(temp[i]); ++_size; &#125; for (int i &#x3D; r; i &gt; mid; --i) &#123; int l &#x3D; 1, r &#x3D; Q.size() - 1, sl &#x3D; h[i] &lt;&lt; 1; while (l &lt;&#x3D; r) &#123; int mid &#x3D; (l + r) &gt;&gt; 1; if (Q[mid] &#x2F; Q[mid - 1] &gt; sl) r &#x3D; mid - 1; else l &#x3D; mid + 1; &#125; int k &#x3D; Q[r].id; dp[i] &#x3D; min(dp[i], dp[k] + (long long) (h[i] - h[k]) * (h[i] - h[k]) + sum[i - 1] - sum[k]); &#125; l &#x3D; mid + 1; &#125; &#125; int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, h + i); for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, w + i), sum[i] &#x3D; sum[i - 1] + w[i]; memset(dp, 0x3f, sizeof dp); dp[1] &#x3D; 0; cdq(1, n); printf(&quot;%lld\\n&quot;, dp[n]); return 0; &#125; 平衡树思路很简洁，一说就懂，一写就废 代码#include &lt;stdio.h&gt; #include &lt;string.h&gt; inline unsigned rand() &#123; static unsigned seed &#x3D; 19260817; return (seed &#x3D; seed * 1279u + 10001279u) ^&#x3D; (seed &gt;&gt; 7); &#125; struct Point &#123; long long x, y; int id; Point(long long _x, long long _y, int _id): x(_x), y(_y), id(_id) &#123;&#125; Point() &#123;&#125; double operator&#x2F; (const Point &amp;p) const &#123; return (double) (y - p.y) &#x2F; (x - p.x); &#125; &#125;; struct Treap &#123; struct node &#123; int ls, rs, size; Point p; double lp, rp; unsigned key; &#125; tr[100005]; int cnt, root; inline int new_node(const Point &amp;p) &#123; tr[++cnt].p &#x3D; p; tr[cnt].key &#x3D; rand(); tr[cnt].size &#x3D; 1; return cnt; &#125; inline void push_up(int k) &#123; if (k) tr[k].size &#x3D; tr[tr[k].ls].size + tr[tr[k].rs].size + 1; &#125; void rotate_left(int &amp;k) &#123; int old_k &#x3D; k; k &#x3D; tr[k].rs; tr[old_k].rs &#x3D; tr[k].ls; tr[k].ls &#x3D; old_k; push_up(old_k); push_up(k); &#125; void rotate_right(int &amp;k) &#123; int old_k &#x3D; k; k &#x3D; tr[k].ls; tr[old_k].ls &#x3D; tr[k].rs; tr[k].rs &#x3D; old_k; push_up(old_k); push_up(k); &#125; int insert(int &amp;k, const Point &amp;v) &#123; int tmp; if (!k) &#123; return k &#x3D; new_node(v); &#125; if (v.x &lt; tr[k].p.x) &#123; if (tmp &#x3D; insert(tr[k].ls, v)) &#123; if (tr[k].key &gt; tr[tr[k].ls].key) rotate_right(k); push_up(k); return tmp; &#125; else return 0; &#125; else if (v.x &gt; tr[k].p.x) &#123; if (tmp &#x3D; insert(tr[k].rs, v)) &#123; if (tr[k].key &gt; tr[tr[k].rs].key) rotate_left(k); push_up(k); return tmp; &#125; else return 0; &#125; else &#123; if (tr[k].p.y &lt; v.y) return 0; tr[k].p.y &#x3D; v.y; tr[k].p.id &#x3D; v.id; return k; &#125; &#125; void remove(int &amp;k, long long x) &#123; if (!k) return; if (tr[k].p.x &#x3D;&#x3D; x) &#123; if (tr[k].ls &amp;&amp; tr[k].rs) &#123; if (tr[tr[k].ls].key &lt; tr[tr[k].rs].key) rotate_right(k), remove(tr[k].rs, x); else rotate_left(k), remove(tr[k].ls, x); &#125; else k &#x3D; tr[k].ls | tr[k].rs; &#125; else if (x &lt; tr[k].p.x) remove(tr[k].ls, x); else remove(tr[k].rs, x); push_up(k); &#125; int rank(long long x) &#123; int rnk &#x3D; 0, k &#x3D; root; while (k) &#123; if (x &lt;&#x3D; tr[k].p.x) k &#x3D; tr[k].ls; else rnk +&#x3D; tr[tr[k].ls].size + 1, k &#x3D; tr[k].rs; &#125; return rnk + 1; &#125; int value(int x) &#123; if (x &gt; tr[root].size || x &lt;&#x3D; 0) return -1; int k &#x3D; root; while (k) &#123; if (x &lt;&#x3D; tr[tr[k].ls].size) k &#x3D; tr[k].ls; else if (x &#x3D;&#x3D; tr[tr[k].ls].size + 1) return k; else x -&#x3D; tr[tr[k].ls].size + 1, k &#x3D; tr[k].rs; &#125; return -1; &#125; int prev(long long v) &#123; return value(rank(v) - 1); &#125; int next(long long v) &#123; return value(rank(v + 1)); &#125; void insert_hull(const Point &amp;point) &#123; int k &#x3D; insert(root, point); if (!k) return; int k1 &#x3D; prev(point.x); if (k1 !&#x3D; -1) &#123; while (tr[k1].lp &gt; point &#x2F; tr[k1].p) remove(root, tr[k1].p.x), k1 &#x3D; prev(tr[k1].p.x); tr[k].lp &#x3D; tr[k1].rp &#x3D; point &#x2F; tr[k1].p; &#125; else tr[k].lp &#x3D; -1e30; int k2 &#x3D; next(point.x); if (k2 !&#x3D; -1) &#123; while (point &#x2F; tr[k2].p &gt; tr[k2].rp) remove(root, tr[k2].p.x), k2 &#x3D; next(tr[k2].p.x); tr[k].rp &#x3D; tr[k2].lp &#x3D; tr[k2].p &#x2F; point; &#125; else tr[k].rp &#x3D; 1e30; if (tr[k].lp &gt; tr[k].rp) &#123; remove(root, tr[k].p.x); tr[k1].rp &#x3D; tr[k2].lp &#x3D; tr[k1].p &#x2F; tr[k2].p; &#125; &#125; int query_hull(long long slope) &#123; int k &#x3D; root; while (k) &#123; if (tr[k].lp &lt;&#x3D; slope &amp;&amp; slope &lt;&#x3D; tr[k].rp) return tr[k].p.id; else if (slope &lt; tr[k].lp) k &#x3D; tr[k].ls; else k &#x3D; tr[k].rs; &#125; return -1; &#125; &#125; treap; int n, w[100005], h[100005]; long long sum[100005], dp[100005]; long long min(long long a, long long b) &#123; return a &lt; b ? a : b; &#125; int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, h + i); for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, w + i), sum[i] &#x3D; sum[i - 1] + w[i]; memset(dp, 0x3f, sizeof dp); dp[1] &#x3D; 0; treap.new_node(Point(h[1], (long long) h[1] * h[1] - w[1], 1)); treap.root &#x3D; 1; treap.tr[1].lp &#x3D; -1e30; treap.tr[1].rp &#x3D; 1e30; for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123; int j &#x3D; treap.query_hull(h[i] &lt;&lt; 1); dp[i] &#x3D; min(dp[i], dp[j] + (long long) (h[i] - h[j]) * (h[i] - h[j]) + sum[i - 1] - sum[j]); treap.insert_hull(Point(h[i], dp[i] + (long long) h[i] * h[i] - sum[i], i)); &#125; printf(&quot;%lld&quot;, dp[n]); return 0; &#125; 二进制分组我们将所有的点分成若干组，第 $ i $ 组大小为 $ 2^i $ ，显然组数不超过 $ O(\\log n) $ 。我们维护每组的凸包。 插入一个点时，若没有第0组，则将它作为第0组，否则将它和第0组合并。这样我们得到了第1组。接下来如果有第1组，则再将它与第1组合并得到第2组……类似二进制+1的过程。 查询在每一组分别二分，取最大即可。 关于时间复杂度： 显然每个点最多被合并 $ O(\\log ⁡n) $ 次。我们合并两个包含 $ O(n) $ 个节点的凸包的时间复杂度是 $ O(n) $ 的，故均摊到每个点上合并的时间复杂度是 $ O(1) $ ，又因为共有 $ O(n) $ 个点，所以总时间复杂度 $ O(n\\log⁡ n) $ 。 代码#include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;vector&gt; int n, h[100005], w[100005]; long long dp[100005], sum[100005]; struct Point &#123; long long x, y; int id; Point(long long _x, long long _y, int _id): x(_x), y(_y), id(_id) &#123;&#125; double operator&#x2F; (const Point &amp;p) const &#123; return (double) (y - p.y) &#x2F; (x - p.x); &#125; &#125;; struct ConvexHull &#123; std::vector&lt;Point&gt; p; void merge(ConvexHull &amp;h) &#123; std::vector&lt;Point&gt; possible_conv; int i &#x3D; 0, j &#x3D; 0; while (i &lt; (int) p.size() &amp;&amp; j &lt; (int) h.p.size()) if (p[i].x &#x3D;&#x3D; h.p[j].x) &#123; if (p[i].y &lt; h.p[j].y) possible_conv.push_back(p[i]); else possible_conv.push_back(h.p[j]); ++i; ++j; &#125; else if (p[i].x &lt; h.p[j].x) possible_conv.push_back(p[i]), ++i; else possible_conv.push_back(h.p[j]), ++j; while (i &lt; (int) p.size()) possible_conv.push_back(p[i]), ++i; while (j &lt; (int) h.p.size()) possible_conv.push_back(h.p[j]), ++j; p.clear(); p.push_back(possible_conv[0]); int _size &#x3D; 0; for (int i &#x3D; 1; i &lt; (int) possible_conv.size(); ++i) &#123; while (_size &amp;&amp; p[_size] &#x2F; p[_size - 1] &gt; p[_size] &#x2F; possible_conv[i]) p.pop_back(), --_size; p.push_back(possible_conv[i]); ++_size; &#125; h.p.clear(); &#125; int query(long long k) &#123; int l &#x3D; 1, r &#x3D; p.size() - 1; while (l &lt;&#x3D; r) &#123; int mid &#x3D; (l + r) &gt;&gt; 1; if (p[mid] &#x2F; p[mid - 1] &gt; k) r &#x3D; mid - 1; else l &#x3D; mid + 1; &#125; return p[r].id; &#125; ConvexHull() &#123;&#125; ConvexHull(const Point &amp;P) &#123; p.push_back(P); &#125; &#125; conv[17]; long long min(long long a, long long b) &#123; return a &lt; b ? a : b; &#125; int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, h + i); for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, w + i), sum[i] &#x3D; sum[i - 1] + w[i]; memset(dp, 0x3f, sizeof dp); dp[1] &#x3D; 0; conv[0] &#x3D; ConvexHull(Point(h[1], (long long) h[1] * h[1] - w[1], 1)); for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123; for (int j &#x3D; 0; j &lt; 17; ++j) &#123; if (conv[j].p.empty()) continue; int k &#x3D; conv[j].query(h[i] &lt;&lt; 1); dp[i] &#x3D; min(dp[i], dp[k] + (long long) (h[i] - h[k]) * (h[i] - h[k]) + sum[i - 1] - sum[k]); &#125; ConvexHull cv(Point(h[i], dp[i] + (long long) h[i] * h[i] - sum[i], i)); for (int j &#x3D; 0; j &lt; 17; ++j) &#123; if (conv[j].p.empty()) &#123; conv[j].p &#x3D; cv.p; break; &#125; cv.merge(conv[j]); &#125; &#125; printf(&quot;%lld&quot;, dp[n]); return 0; &#125; 总结在 $ dp $ 的最小/最大化问题中，将转移方程分成四部分：一部分与 $ i, j $ 都无关，一部分只与 $ j $ 有关，一部分只与 $ i $ 有关，还有一部分和 $ i, j $ 都有关。如果它能写成 $ y=kx+b $ 的形式，我们就可以维护一个凸包，来进行状态的转移。 怎么样，你学会(废)了吗 练习 此处放出你谷的链接 P4655 / loj 2483 Building Bridges P5017 / loj 3007 [NOIP2018 普及组] 摆渡车 P4027 / loj 2353 [NOI2007] 货币兑换 P3571 [POI2014] SUP-Supercomputer CF311B Cats Transport","categories":[{"name":"教程","slug":"教程","permalink":"http://www.honahec.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.honahec.com/tags/C/"}]},{"title":"矩阵","slug":"ju-zhen","date":"2021-06-25T13:52:15.000Z","updated":"2021-09-17T12:45:11.494Z","comments":true,"path":"ju-zhen/","link":"","permalink":"http://www.honahec.com/ju-zhen/","excerpt":"","text":"矩阵矩阵(Matrix)定义一个 $ n\\times m $ 的矩阵是一个由 $ n $ 行 $ m $ 列元素排成的矩形阵列。矩阵里的元素可以是数字符号或者数学式。 形如 $ \\left(\\begin{matrix}a&amp;b\\\\c&amp;d\\end{matrix}\\right) $ 的数表称为二阶矩阵，它由二行二列组成，其中 $ a,b,c,d $ 称为这个矩阵的元素。 形如 $ \\left(\\begin{matrix}x_1\\\\x_2\\end{matrix}\\right) $ 的有序对称为列向量(Column Vector) 矩阵加法矩阵的加法非常简单 对，就是你想的那样 \\left( \\begin{matrix} a_{1,1}&a_{1,2}&\\cdots&a_{1,m}\\\\a_{2,1}&a_{2,1}&\\cdots&a_{2,m}\\\\\\vdots&\\vdots&&\\vdots\\\\a_{n,1}&a_{n,2}&\\cdots&a_{n,m} \\end{matrix} \\right)\\pm \\left( \\begin{matrix} b_{1,1}&b_{1,2}&\\cdots&b_{1,m}\\\\b_{2,1}&b_{2,1}&\\cdots&b_{2,m}\\\\\\vdots&\\vdots&&\\vdots\\\\b_{n,1}&b_{n,2}&\\cdots&b_{n,m} \\end{matrix} \\right)= \\left( \\begin{matrix} a_{1,1}\\pm b_{1,1}&a_{1,2}\\pm b_{1,2}&\\cdots&a_{1,m}\\pm b_{1,m}\\\\a_{2,1}\\pm b_{2,1}&a_{2,1}\\pm b_{2,2}&\\cdots&a_{2,m}\\pm b_{2, m}\\\\\\vdots&\\vdots&&\\vdots\\\\a_{n,1}\\pm b_{n,1}&a_{n,1}\\pm b_{n,2}&\\cdots&a_{n,m}\\pm b_{n,m} \\end{matrix} \\right)注意：两个矩阵必须为同型矩阵(即必须都是 $ n\\times m $ 的矩阵)才能相加 并且，矩阵加减法满足交换律和结合律(即 $ A+B=B+A $ ， $ (A+B)+C=A+(B+C) $ ) 矩阵乘法矩阵乘法稍有不同 嗯，真的只有一点不同 如果有矩阵 $ A $ 大小为 $ n\\times m $ ，矩阵 $ B $ 大小为 $ m\\times s $ ，相乘为矩阵 $ C $ ，矩阵 $ C $ 的大小一定为 $ n\\times s $ 矩阵乘法遵循 $ C=\\sum_{k=1}^{m}a_{i,k}b_{k,j} $ 嗯，只有一点 举个例子设 \\begin{align} A&=\\left(\\begin{matrix}a&b\\\\c&d\\end{matrix}\\right)\\\\\\\\ B&=\\left(\\begin{matrix}x_1\\\\x_2\\end{matrix}\\right)\\\\ \\end{align}则 \\begin{align} C=AB&=\\left(\\begin{matrix}ax_1+bx_2\\\\cx_1+dx_2\\end{matrix}\\right)\\\\ \\end{align}称为二阶矩阵 $ A $ 与平面向量 $ B $ 的乘积，记为 $ AB=C $ 利用矩阵求斐波那契(Fibonacci)数列众所周知，斐波那契数列从第三项开始，每一项都是前两项之和 即 $ F_n=F_{n-1}+F_{n-2},n\\geq3 $ 特别的 $ F_0=0,F_1=F_2=1 $ 把斐波那契数列中相邻的两项( $ F_n $ 和 $ F_{n-1} $ )写成一个 $ 2\\times1 $ 的矩阵 \\begin{align} &=\\left( \\begin{matrix} F_n\\\\ F_{n-1} \\end{matrix} \\right)\\\\\\\\ &=\\left( \\begin{matrix} F_{n-1}+F_{n-2}\\\\ F_{n-1} \\end{matrix} \\right)\\\\\\\\ &=\\left( \\begin{matrix} 1\\times F_{n-1}+1\\times F_{n-2}\\\\ 1\\times F_{n-1}+0\\times F_{n-2} \\end{matrix} \\right)\\\\\\\\ &=\\left( \\begin{matrix} 1&1\\\\ 1&0 \\end{matrix} \\right) \\times \\left( \\begin{matrix} F_{n-1}\\\\ F_{n-2} \\end{matrix} \\right)\\\\\\\\ &=\\left( \\begin{matrix} 1&1\\\\ 1&0 \\end{matrix} \\right)^{n-1} \\times \\left( \\begin{matrix} F_1\\\\ F_0 \\end{matrix} \\right)\\\\\\\\ &=\\left( \\begin{matrix} 1&1\\\\ 1&0 \\end{matrix} \\right)^{n-1} \\times \\left( \\begin{matrix} 1\\\\ 0 \\end{matrix} \\right) \\end{align}求 $ F_n $ 等同于求二阶矩阵的 $ n-1 $ 次方，结果取矩阵第一行元素。 问题转换为二阶矩阵的 $ n $ 次幂 求二阶矩阵的 $ N $ 次幂这里可以回顾一下矩阵乘法 假设计算矩阵 $ A $ 的 $ N $ 次幂 方法一二阶矩阵的乘法满足结合律 设 $ A,B,C $ 都是任意的二阶矩阵 则 $ A(BC)=(AB)C $ 不在此证明 设 $ n=N\\div 2 $ (结果向下取整) 若 $ N\\in 2k $ 则 $ A^N=A^n\\times A^n $ 若 $ N\\in 2k+1 $ 则 $ A^N=A^n\\times A^n\\times A $ 这样可以减少计算次数，自行思考原因 方法二以计算 $ A^6 $ 为例 例如 $ 6_{(10)}=110_{(2)} $ 则 $ A^6=A^4\\times A^2 $ 上图显示二进制与幂的指数关系 二进位为1需要乘，为0不需要乘 再例如 $ 7_{(10)}=111_{(2)} $ 则 $ A^7=A^4\\times A^2\\times A^1 $ 先随随便便写一个求快速幂的代码(相信大家都会写吧 int qpow(int a, int k) &#123; int res &#x3D; 1; while(k) &#123; if(a &amp; 1) res *&#x3D; a; k &gt;&gt;&#x3D; 1; a *&#x3D; a; &#125; return res; &#125; 那么到底怎么用矩阵求斐波那契数列呢？ 代码#include&lt;cstdio&gt; #include&lt;cstring&gt; struct Matrix &#123; long long fib[2][2]; Matrix() &#123;memset(fib, 0, sizeof fib);&#125; &#125;; Matrix qmul(Matrix &amp;a, Matrix &amp;b) &#123; Matrix c; for(int i &#x3D; 0; i &lt; 2; ++i) &#123; for(int j &#x3D; 0; j &lt; 2; ++j) &#123; for(int k &#x3D; 0; k &lt; 2; ++k) &#123; c.fib[i][j] +&#x3D; a.fib[i][k] * b.fib[k][j]; &#125; &#125; &#125; return c; &#125; Matrix qpow(Matrix a, long long k) &#123; Matrix ans; ans.fib[0][0] &#x3D; ans.fib[1][1] &#x3D; 1; while(k) &#123; if(k &amp; 1) ans &#x3D; qmul(ans, a); a &#x3D; qmul(a, a); k &gt;&gt;&#x3D; 1; &#125; return ans; &#125; int main() &#123; long long n; Matrix a, b; scanf(&quot;%lld&quot;, &amp;n); a.fib[0][0] &#x3D; a.fib[0][1] &#x3D; a.fib[1][0] &#x3D; 1; b &#x3D; qpow(a, n); printf(&quot;%lld\\n&quot;, b.fib[0][1]); return 0; &#125; 你学 废 会了吗","categories":[{"name":"教程","slug":"教程","permalink":"http://www.honahec.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.honahec.com/tags/C/"}]},{"title":"打鼹鼠","slug":"da-yan-shu","date":"2021-06-25T13:51:07.000Z","updated":"2021-09-17T12:45:11.487Z","comments":true,"path":"da-yan-shu/","link":"","permalink":"http://www.honahec.com/da-yan-shu/","excerpt":"","text":"题目链接P2285 打鼹鼠 思路很明显，这是一道 $ dp $ 题，因为标签已经告诉我们了（不是 怎么 $ dp $ 呢？ 棋盘？三维必炸啊，二维本蒟蒻不会 时间？更离谱了 所以就只能从鼹鼠下手了 设 $ dp_i $ 为到第 $ i $ 只鼹鼠时最多能打到几只 因为我们要守株待兔（鼠），所以初始化 $ dp_i=1 $ 若两鼹鼠之间的曼哈顿距离小于出现时间差 此时转移方程为 $ dp_i=min(dp[i],dp[j]+1) $ 代码#include&lt;cstdio&gt; #include&lt;cmath&gt; #define fo(i,x,y) for(register int i&#x3D;x;i&lt;&#x3D;y;++i) #define go(i,x,y) for(register int i&#x3D;x;i&gt;&#x3D;y;--i) #define INF 0x3f3f3f3f #define il inline #define ll long long #define ull unsigned long long using namespace std; const int N &#x3D; 1005, M &#x3D; 10005; int n, m, dp[M], ans; struct NODE &#123; int time, x, y; &#125;node[M]; il int max(const int &amp;a, const int &amp;b) &#123;return a &gt; b ? a : b;&#125; int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); fo(i, 1, m) scanf(&quot;%d%d%d&quot;, &amp;node[i].time, &amp;node[i].x, &amp;node[i].y), dp[i] &#x3D; 1; fo(i, 1, m) &#123; fo(j, 1, i - 1) &#123; if(abs(node[i].x - node[j].x) + abs(node[i].y - node[j].y) &lt;&#x3D; abs(node[i].time - node[j].time)) &#123; dp[i] &#x3D; max(dp[i], dp[j] + 1); &#125; &#125; &#125; fo(i, 1, m) ans &#x3D; max(ans, dp[i]); printf(&quot;%d\\n&quot;, ans); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.honahec.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.honahec.com/tags/C/"}]},{"title":"Radio Contact G","slug":"radio-contact-g","date":"2021-06-25T13:50:26.000Z","updated":"2021-09-17T12:45:11.484Z","comments":true,"path":"radio-contact-g/","link":"","permalink":"http://www.honahec.com/radio-contact-g/","excerpt":"","text":"题目链接P3133 Radio Contact G 思路 $ dp $ 题 设 $ dp_{i,j} $ 为Farmer John走到第i步，Bessie走到第j步需要的最小能量 很容易得到转移方程 $ f_{i,j}=min(f_{i-1,j},f_{i,j-1},f_{i-1,j-1})+dist $ 其中 $ dist $ 为Farmer John在第i步，Bessie在第j步时他们欧几里得距离的平方 即 $ (x_1-x_2)^2-(y_1-y_2)^2 $ 注意一下初始化：f[i][0] &#x3D; f[i - 1][0] + dist; f[0][i] &#x3D; f[i - 1][0] + dist; f[0][0] &#x3D; 0; &#x2F;&#x2F;初始位置不消耗能量 然后这道题就愉快的AC了 代码#include&lt;cstdio&gt; #include&lt;cstring&gt; #define fo(i,x,y) for(register int i&#x3D;x;i&lt;&#x3D;y;++i) #define go(i,x,y) for(register int i&#x3D;x;i&gt;&#x3D;y;--i) #define INF 0x3f3f3f3f #define il inline #define ll long long #define ull unsigned long long using namespace std; const int N &#x3D; 1005; int n, m, fx, fy, bx, by; char fs[N], bs[N]; int f[N][N]; il int min(const int &amp;a, const int &amp;b) &#123;return a &lt; b ? a : b;&#125; il void move(int &amp;x, int &amp;y, const char &amp;t) &#123; switch(t) &#123; case &#39;N&#39;: ++y; break; case &#39;S&#39;: --y; break; case &#39;E&#39;: ++x; break; case &#39;W&#39;: --x; break; &#125; &#125; il int dist(const int &amp;x1, const int &amp;y1, const int &amp;x2, const int &amp;y2) &#123; return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2); &#125; int main() &#123; scanf(&quot;%d%d%d%d%d%d%s%s&quot;, &amp;n, &amp;m, &amp;fx, &amp;fy, &amp;bx, &amp;by, fs + 1, bs + 1); int lenf &#x3D; strlen(fs + 1), lenb &#x3D; strlen(bs + 1); int tx1 &#x3D; fx, ty1 &#x3D; fy, tx2 &#x3D; bx, ty2 &#x3D; by; fo(i, 1, lenf) &#123; move(tx1, ty1, fs[i]); f[i][0] &#x3D; f[i - 1][0] + dist(tx1, ty1, bx, by); &#125; fo(i, 1, lenb) &#123; move(tx2, ty2, bs[i]); f[0][i] &#x3D; f[0][i - 1] + dist(fx, fy, tx2, ty2); &#125;&#x2F;&#x2F;初始化 tx1 &#x3D; fx, ty1 &#x3D; fy; fo(i, 1, lenf) &#123; tx2 &#x3D; bx, ty2 &#x3D; by; move(tx1, ty1, fs[i]); fo(j, 1, lenb) &#123; move(tx2, ty2, bs[j]); f[i][j] &#x3D; min(f[i - 1][j], min(f[i][j - 1], f[i - 1][j - 1])) + dist(tx1, ty1, tx2, ty2); &#125; &#125; printf(&quot;%lld\\n&quot;, f[lenf][lenb]); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.honahec.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.honahec.com/tags/C/"}]},{"title":"有理数取余","slug":"you-li-shu-qu-yu","date":"2021-06-25T13:49:03.000Z","updated":"2021-09-17T12:45:11.492Z","comments":true,"path":"you-li-shu-qu-yu/","link":"","permalink":"http://www.honahec.com/you-li-shu-qu-yu/","excerpt":"","text":"题目描述P2613 【模板】有理数取余 题目非常简单易懂给出一个有理数 $ c=\\frac{a}{b} $，求 $ c\\bmod19260817 $ 的值。 思路看到这道题时 第一眼：好像很简单啊 第二眼：$ a,b\\leq10^{10001} $？！！ 第三眼：卧槽这啥玩意？！！ 要做这道题，我们来介绍一个新的东西（主要是本蒟蒻不会exgcd（欧几里得扩展） 逆元 P 是一个质数 令 $ b’ $ 为 $ b $ 的逆元，那么有$ b\\times b’\\equiv1\\,(mod\\,P) $ 有 $ \\frac{a}{b}\\equiv\\frac{a}{b}\\times1\\equiv\\frac{a}{b}\\times(b\\times b’)\\equiv a\\times b’\\,(mod\\,P) $ 显然可以看出 $ b’ $ 的值为 $ \\frac{1}{b} $ 但是除以 $ b $ 与乘以 $ \\frac{1}{b} $ 是一样的啊，怎么办呢？ 费马小定理闪亮登场定理内容：如果 $ p$ 是一个质数，而整数 $ a$ 不是 $ p$ 的倍数，则有$ a^{p-1}\\equiv1\\,(mod\\,p) $ 证明你可以选择跳过这部分 证明部分 $ p $ 是一个质数 第一个证明首先我们考虑一个前置定理： 若$ gcd(c,p)=1 $，且$ ac\\equiv bc\\,(mod\\,p) $，那么有$ a\\equiv b\\,(mod\\,p) $ 证： \\begin{align} &\\because ac\\equiv bc\\,(mod\\,p)\\\\ &\\therefore (a-b)c\\equiv 0\\,(mod\\,p)\\\\ &\\therefore (a-b)c\\,是\\,p\\,的整数倍\\\\ 又&\\because gcd(c,p)=1\\\\ &\\therefore a-b\\equiv0\\,(mod\\,p)\\\\ &即a\\equiv b\\,(mod\\,p) \\end{align}证毕 第二个证明然后我们进入正题，假设有正整数$ a(a&lt;p) $ 满足条件$ gcd(a,p)=1 $，那么我们将 $ a $ 乘上 $ 1\\thicksim p-1 $ 后可以构成一个 $ mod\\,p $ 的完全剩余系 证： \\begin{align} &假设存在xa\\equiv ya\\,(mod\\,p),且x\\neq y\\\\ &\\because gcd(a,p)=1\\\\ &\\therefore 原式成立当且仅当x\\equiv y\\,(mod\\,p)\\\\ 又&\\because x,y\\in [1,p-1]\\\\ &\\therefore x\\equiv y\\,(mod\\,p)当且仅当x=y,与已知条件矛盾\\\\ &\\therefore 假设不成立，原命题成立 \\end{align}证毕 第三个证明接下来证明 $ a^{p-1}\\equiv1\\,(mod\\,p) $ 证： \\begin{align} &\\because 1,2,\\cdots,p-1是\\,mod\\,p\\,的完全剩余系\\\\ &\\therefore有1\\times2\\times\\cdots\\times p-1\\equiv a\\times2a\\times\\cdots\\times (p-1)a\\,(mod\\,p)\\\\ &即 (p-1)!\\equiv (p-1)!\\times a^{p-1}\\,(mod\\,p)\\\\ 又&\\because p是质数\\\\ &\\therefore gcd((p-1)!,p)=1\\\\ &\\therefore a^{p-1}\\equiv1\\,(mod\\,p) \\end{align}证毕 回归正题根据费马小定理，显然 $ b’=b^{P-2} $ 什么？不显然吗？ \\begin{align} \\because b'\\times b&\\equiv1\\,(mod\\,P)\\\\ b^{P-1}&\\equiv1\\,(mod\\,P)\\\\ \\therefore b'\\times b&\\equiv b^{P-1}\\,(mod\\,P)\\\\ \\therefore b'&=b^{P-2} \\end{align}那么 $ \\frac{a}{b}=a\\times b^{P-2} $ 然后我们就可以用快速幂轻松A掉这题了（$ ps$ ：虽然快速幂让我们不需要高精了，但long long还是要的 代码#include&lt;cstdio&gt; const int MOD &#x3D; 19260817; inline long long read() &#123; long long X &#x3D; 0, flag &#x3D; 1; char ch &#x3D; getchar(); while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;if(ch &#x3D;&#x3D; &#39;-&#39;) flag &#x3D; 0; ch&#x3D;getchar();&#125; while(ch &gt;&#x3D; &#39;0&#39; &amp;&amp; ch &lt;&#x3D; &#39;9&#39;) &#123;X &#x3D; (X * 10 + (ch ^ 48)) % MOD; ch &#x3D; getchar();&#125; return flag ? X : -X; &#125; long long a, b; long long QuickPow(long long x, long long y) &#123; long long ans &#x3D; 1, k &#x3D; MOD - 2; while(k) &#123; if(k &amp; 1) ans &#x3D; ans * x % MOD; x &#x3D; x * x % MOD; k &gt;&gt;&#x3D; 1; &#125; return ans * y % MOD; &#125;&#x2F;&#x2F;快速幂不建议这样写，还是用模板比较好 int main() &#123; a &#x3D; read(); b &#x3D; read(); if(b) printf(&quot;%lld\\n&quot;, QuickPow(b, a)); else printf(&quot;Angry!\\n&quot;); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://www.honahec.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://www.honahec.com/tags/C/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-06-25T13:38:19.000Z","updated":"2021-09-19T07:20:34.480Z","comments":true,"path":"hello-world/","link":"","permalink":"http://www.honahec.com/hello-world/","excerpt":"","text":"Hello 大家好啊我是Honahec，一个蒟蒻 目前这个博客仍在建设中，如果您有任何想法都可以在上方的留言板中留言或者添加我的QQ，我会及时回复并采纳部分建议 如果您也想要建设一个属于自己的博客也可以联系我 谢谢大家 #include&lt;cstdio&gt; int main() &#123; printf(&quot;Hello World!\\n&quot;); return 114514; &#x2F;&#x2F;:) &#125;","categories":[{"name":"随便说说","slug":"随便说说","permalink":"http://www.honahec.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"}],"tags":[{"name":"摸鱼","slug":"摸鱼","permalink":"http://www.honahec.com/tags/%E6%91%B8%E9%B1%BC/"}]}],"categories":[{"name":"比赛","slug":"比赛","permalink":"http://www.honahec.com/categories/%E6%AF%94%E8%B5%9B/"},{"name":"随便说说","slug":"随便说说","permalink":"http://www.honahec.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"},{"name":"教程","slug":"教程","permalink":"http://www.honahec.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"题解","slug":"题解","permalink":"http://www.honahec.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"游记","slug":"游记","permalink":"http://www.honahec.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"摸鱼","slug":"摸鱼","permalink":"http://www.honahec.com/tags/%E6%91%B8%E9%B1%BC/"},{"name":"C++","slug":"C","permalink":"http://www.honahec.com/tags/C/"}]}