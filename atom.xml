<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Honahec</title>
  
  <subtitle>Honahec</subtitle>
  <link href="http://www.honahec.com/atom.xml" rel="self"/>
  
  <link href="http://www.honahec.com/"/>
  <updated>2021-09-19T11:56:36.967Z</updated>
  <id>http://www.honahec.com/</id>
  
  <author>
    <name>Honahec</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>csp2021</title>
    <link href="http://www.honahec.com/csp2021/"/>
    <id>http://www.honahec.com/csp2021/</id>
    <published>2021-09-19T11:23:26.000Z</published>
    <updated>2021-09-19T11:56:36.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="day-3"><a href="#day-3" class="headerlink" title="day -3"></a>day -3</h3><p>快初赛了</p><p>刷完这个NOIP2016就都刷完了</p><p>83.5还行</p><p>（感觉充满了信心）</p><h3 id="day-1"><a href="#day-1" class="headerlink" title="day -1"></a>day -1</h3><p>明天就要初赛了</p><p>大半夜的我仍在快乐地刷视频qwq</p><h3 id="day-0"><a href="#day-0" class="headerlink" title="day 0"></a>day 0</h3><p>（早上的我此刻还没有意识到事情的严重性）</p><p>这题怎么一年比一年阴间</p><p>什么base64编码，笛卡尔树+Euler序列搞RMQ</p><p>最后一题还121行</p><p>完全不会呜呜呜</p><p>合分56.5，坐标SD，很慌</p><p><strong>如果能过会继续在这篇博客更新复赛</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;day-3&quot;&gt;&lt;a href=&quot;#day-3&quot; class=&quot;headerlink&quot; title=&quot;day -3&quot;&gt;&lt;/a&gt;day -3&lt;/h3&gt;&lt;p&gt;快初赛了&lt;/p&gt;
&lt;p&gt;刷完这个NOIP2016就都刷完了&lt;/p&gt;
&lt;p&gt;83.5还行&lt;/p&gt;
&lt;p&gt;（感觉充满</summary>
      
    
    
    
    <category term="比赛" scheme="http://www.honahec.com/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
    <category term="游记" scheme="http://www.honahec.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ACSL游记</title>
    <link href="http://www.honahec.com/acsl-you-ji/"/>
    <id>http://www.honahec.com/acsl-you-ji/</id>
    <published>2021-09-14T11:24:25.000Z</published>
    <updated>2021-09-17T12:45:11.477Z</updated>
    
    <content type="html"><![CDATA[<p>前不久<del>(其实也没有不久啦</del>本蒟蒻去参加了ACSL</p><h3 id="Day-5"><a href="#Day-5" class="headerlink" title="Day -5"></a>Day -5</h3><p>因为没有队友，ASDAN给我随机匹配到了一位<a href="https://github.com/Nambers">大佬</a>qwq</p><p>第一个任务是自制游戏并录制vlog！？？我直接人傻了，幸好大佬曾经自己做过一点，我们就很随意地直接使用了那个游戏，然后很随意地制作了一个vlog</p><p>主要是5天也做不了游戏啊（可能是我太菜了</p><p><a href="https://github.com/Nambers/abattoir">游戏源码</a></p><p>vlog：</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=932985969&bvid=BV14M4y1g7C5&cid=408218084&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p><del>这比赛为什么要打一天！？？</del></p><h4 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h4><p>选择题直接被lisp打蒙了（明明复习过了，但有些根本百度不到呜呜呜</p><p>喜提15/20</p><h4 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h4><p>大概看了一眼题目：就这？？</p><p>不得不说，是真的水</p><p>t2我直接20分钟切掉</p><p>为什么先说t2呢</p><p>因为t1有4个点就是调不对，这就是不会打对拍的痛苦吗qwq</p><p>喜提16/20</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>感觉自己一到最后就总是出一些奇奇怪怪的问题，唉</p><p>csp冲冲冲！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前不久&lt;del&gt;(其实也没有不久啦&lt;/del&gt;本蒟蒻去参加了ACSL&lt;/p&gt;
&lt;h3 id=&quot;Day-5&quot;&gt;&lt;a href=&quot;#Day-5&quot; class=&quot;headerlink&quot; title=&quot;Day -5&quot;&gt;&lt;/a&gt;Day -5&lt;/h3&gt;&lt;p&gt;因为没有队友，ASDAN给我</summary>
      
    
    
    
    <category term="随便说说" scheme="http://www.honahec.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"/>
    
    
    <category term="游记" scheme="http://www.honahec.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>博客维护动态</title>
    <link href="http://www.honahec.com/update/"/>
    <id>http://www.honahec.com/update/</id>
    <published>2021-09-05T08:43:27.000Z</published>
    <updated>2021-09-19T07:10:04.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="update-2021-9-5"><a href="#update-2021-9-5" class="headerlink" title="update 2021.9.5"></a>update 2021.9.5</h3><p>数学公式已经维护完毕！！！（起码目前看来是这样的</p><h3 id="update-2021-9-12"><a href="#update-2021-9-12" class="headerlink" title="update 2021.9.12"></a>update 2021.9.12</h3><p>今天瞎搞了一下，优化了体验（但为什么不能页内跳转了qwq，我还没备份…瞎搞有风险，记得备份呜呜呜</p><h3 id="update-2021-9-19"><a href="#update-2021-9-19" class="headerlink" title="update 2021.9.19"></a>update 2021.9.19</h3><p><strong>更换主题为Volantis</strong></p><p>添加友链页面（欢迎互换）</p><p>添加about页面</p><p>添加开往</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;update-2021-9-5&quot;&gt;&lt;a href=&quot;#update-2021-9-5&quot; class=&quot;headerlink&quot; title=&quot;update 2021.9.5&quot;&gt;&lt;/a&gt;update 2021.9.5&lt;/h3&gt;&lt;p&gt;数学公式已经维护完毕！！！（起码目前</summary>
      
    
    
    
    <category term="随便说说" scheme="http://www.honahec.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"/>
    
    
    <category term="摸鱼" scheme="http://www.honahec.com/tags/%E6%91%B8%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>斜率优化dp</title>
    <link href="http://www.honahec.com/xie-lv-you-hua-dp/"/>
    <id>http://www.honahec.com/xie-lv-you-hua-dp/</id>
    <published>2021-06-25T13:53:49.000Z</published>
    <updated>2021-09-17T12:45:11.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="斜率优化-dp"><a href="#斜率优化-dp" class="headerlink" title="斜率优化 $ dp $"></a>斜率优化 $ dp $</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><div class="table-container"><table><thead><tr><th>名称</th><th>定义</th></tr></thead><tbody><tr><td>凸多边形</td><td>所有内角都在 $ (0°,180°) $ 的简单多边形</td></tr><tr><td>凸包</td><td>在平面上能包含所有给定点的最小凸多边形叫做凸包。</td></tr><tr><td>上凸包</td><td>凸包中横坐标最小的点到横坐标最大的点的上半部分</td></tr><tr><td>下凸包</td><td>凸包中横坐标最小的点到横坐标最大的点的下半部分</td></tr></tbody></table></div><center>如下图，蓝色部分是上凸包，橙色部分是下凸包</center><p><img src="https://cdn.jsdelivr.net/gh/Calm00/PicGo/img/dp1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/Calm00/PicGo/img/dp1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:25%;" /></p><blockquote><p>让我们通过例题来学习斜率优化 $ dp $ </p></blockquote><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="HNOI2008-玩具装箱"><a href="#HNOI2008-玩具装箱" class="headerlink" title="[HNOI2008] 玩具装箱"></a><a href="https://www.luogu.com.cn/problem/P3195">[HNOI2008] 玩具装箱</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。</p><p>P 教授有编号为  $ 1 \cdots n $  的  $ n $  件玩具，第件玩具经过压缩后的一维长度为  $ C_i $ 。</p><p>为了方便整理，P教授要求：</p><ul><li>在一个一维容器中的玩具编号是连续的。</li><li>同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第  $ i $  件玩具到第  $ j $  个玩具放到一个容器中，那么容器的长度将为  $ x=j-i+\sum_{k=i}^{j}C_k $ 。</li></ul><p>制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为  $ x $ ，其制作费用为  $ (x-L)^2 $ 。其中  $ L $  是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过  $ L $ 。但他希望所有容器的总费用最小。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行有两个整数，用一个空格隔开，分别代表  $ n $  和  $ L $ 。</p><p>第  $ 2 $  到 第  $ (n+1) $  行，每行一个整数，第  $ (i+1) $  行的整数代表第  $ i $  件玩具的长度  $ C_i $ 。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一行一个整数，代表所有容器的总费用最小是多少。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于全部的测试点， $ 1 \leq n \leq 5 \times 10^4,1 \leq L \leq 10^7,1 \leq C_i \leq 10^7 $ </p><h3 id="基本-dp-思路"><a href="#基本-dp-思路" class="headerlink" title="基本 $ dp $ 思路"></a>基本 $ dp $ 思路</h3><p>设 $ F_i $ 为装前 $ i $ 个玩具的最小费用，则 $ F_i=min_{0\leq j&lt;i}(F_j+(i-j-1-L+\sum^{i}_{k=j+1}C_k)^2) $ </p><p>其中 $ \sum^{i}_{k = j+1} C_k $ 可以用前缀和优化掉，变成 $ F_i = min_{0 \leq j&lt;i}(F_j+(i-j-1-L+sum_i-sum_j)^2) $ </p><p>非常好啊， $ O(n^2) $ ，0分到手</p><p>怎么办呢？</p><h3 id="处理一下"><a href="#处理一下" class="headerlink" title="处理一下"></a>处理一下</h3><p>这个 $ dp $ 方程好像不太好处理</p><p>首先我们不看这个 $ min $ ，只看 $ F_i=F_j+(i-j-1-L+sum_i-sum_j )^2 $ </p><script type="math/tex; mode=display">\begin{align}令A=i+sum_i，B&=j+sum_j，C=L+1\\F_j+(A-B-C)^2&=F_j+A^2+(B+C)^2-2A(B+C)\\F_i+2A(B+C)&=F_j+A^2+(B+C)^2\\令x=B+C，y=F_j&+(B+C)^2，k=2A，b=F_i-A^2\\y&=kx+b\end{align}</script><p>想到了什么？</p><p>我们要最小化 $ F_i $ ，那也就是说我们要最小化 $ b $ </p><p>对于每一个确定的 $ i $ ， $ k $ 都是确定的</p><p>问题转化成了求过 $ (B+C, F_j+(B+C)^2) $ 中任意一点且斜率为k的直线截距的最小值。</p><h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><p><strong>如果你只想知道斜率优化怎么用，那么你可以<a href="#toc-heading-11">点此</a>跳过这部分。</strong></p><p>我们易可证截距的最小值一定取在下凸包上</p><p>证明：假如截距的最小值取在非下凸包上的一个点 $ (x_0,y_0 ) $ ，则有两种情况：</p><p>（一） 下凸包上有一个点 $ (x_0,y_1) $ </p><p>所以过 $ (x_0,y_0) $ 的直线的解析式为 $ y=kx+y_0-kx_0 $ ，过 $ (x_0,y_1) $ 的直线的解析式为 $ y=kx+y_1-kx_0 $ </p><p>根据下凸包的定义可得 $ y_0&gt;y_1 $ ，故 $ y_0-kx_0&gt;y_1-kx_1 $ ，矛盾</p><p>（二） 下凸包上没有和其横坐标相同的点</p><p>根据下凸包的定义，可得下凸包上一定存在两个点 $ (x_1,y_1) $ , $ (x_2,y_2) $ 使得 $ x_1&lt;x_0&lt;x_2 $ 且 $ x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}&lt;y_0 $ </p><p>我们在经过 $ (x_1,y_1) $ ,  $ (x_2,y_2) $ 的直线上取一点 $ (x_0,x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-xx_2}) $ </p><ul><li>过 $ (x_0,y_0) $ 的直线解析式为 $ y=kx+y_0-kx_0 $ </li><li>过 $ (x_0,x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}) $ 的为 $ y=kx+x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0 $ </li><li>过 $ (x_1,y_1) $ 的为 $ y=kx+y_1-kx_1 $ </li><li>过 $ (x_2,y_2) $ 的为 $ y=kx+y_2-kx_2 $ </li></ul><p>由（一）可得 $ y_0-kx_0&gt;x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0 $ </p><script type="math/tex; mode=display">\begin{align}&k>\frac{y_1-y_2}{x_1-x_2}\\&(x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2 }-kx_0)-(y_1-kx_1 )\\&=\frac{x_0 y_1-x_0 y_2+x_1 y_2-x_1 y_1}{x_1-x_2}-k(x_1-x_0)\\&=\frac{(x_0-x_1)(y_1-y_2)}{x_1-x_2}-k(x_0-x_1)\\&>\frac{(x_0-x_1 )(y_1-y_2)}{x_1-x_2}-\frac{(x_0-x_1)(y_1-y_2 )}{x_1-x_2}\\&=0\end{align}</script><script type="math/tex; mode=display">\begin{align}&k\leq\frac{y_1-y_2}{x_1-x_2}\\&(𝑥_0\frac{𝑦_1−𝑦_2}{𝑥_1−𝑥_2}+\frac{𝑥_1 𝑦_2−𝑥_2 𝑦_1}{𝑥_1−𝑥_2}−𝑘𝑥_0 )−(𝑦_2−𝑘𝑥_2 )\\&=\frac{𝑥_0 𝑦_1−𝑥_0 𝑦_2+𝑥_2 𝑦_2−𝑥_2 𝑦_1}{𝑥_1−𝑥_2}−𝑘(𝑥_2−𝑥_0)\\&=\frac{(𝑥_0−𝑥_2 )(𝑦_1−𝑦_2 )}{𝑥_1−𝑥_2}−𝑘(𝑥_0−𝑥_2 )\\&≥\frac{(𝑥_0−𝑥_2 )(𝑦_1−𝑦_2 )}{𝑥_1−𝑥_2}−\frac{(𝑥_0−𝑥_2 )(𝑦_1−𝑦_2 )}{𝑥_1−𝑥_2}\\&=0\end{align}</script><ul><li>综上所述，在 $ y_1-kx_1 $ 和 $ y_2-kx_2 $ 中一定存在一个数小于或等于 $ x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0 $ ，又因为 $ y_0-kx_0&gt;x_0\frac{y_1-y_2}{x_1-x_2}+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}-kx_0 $ ，所以在 $ y_1-kx_1 $ 和 $ y_2-kx_2 $ 中一定存在一个数小于 $ y_0-kx_0 $ ，矛盾。</li><li>综上所述，此截距的最小值一定取在下凸包上。</li><li>证毕。</li></ul><h4 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h4><p>现在我们知道了最优决策点一定在下凸包上</p><p>那么我们怎么找最优决策点呢？</p><p>首先我们易得下凸包中所有线的斜率一定是<strong>单调递增</strong>的</p><p>如果存在三个下凸包中的点 $ (x_1,y_1 ) $ ， $ (x_2,y_2 ) $ ， $ (x_3,y_3 ) $ 使得 $ x_1 &lt; x_2 &lt; x_3 $ 且 $ \frac{y_2-y_1}{x_2-x_1} &gt; \frac{y_3-y_2}{x_3-x_2} $ ，则 $ y_2 - \frac{y_3-y_1}{x_3-x_1} x_2 - \frac{x_3 y_1-x_1 y_3}{x_3-x_1} = \frac{-x_1 y_2+x_1 y_3+x_2 y_1-x_2 y_3-x_3 y_1+x_3 y_2}{x_3-x_1} $  </p><p>又因为 $ x_1 &lt; x_2 &lt; x_3 $ ，所以 $ x_2-x_1 &gt; 0 $ ， $ x_3-x_2 &gt; 0 $ ， $ x_3-x_1 &gt; 0 $ </p><p>故 $ (y_2-y_1 )(x_3-x_2 )&gt;(y_3-y_2 )(x_2-x_1 ) $ ，即 $ x_2 y_1-x_3 y_1+x_3 y_2&gt;x_1 y_2-x_1 y_3+x_2 y_3 $ </p><p>所以 $ \frac{-x_1 y_2+x_1 y_3+x_2 y_1-x_2 y_3-x_3 y_1+x_3 y_2}{x_3-x_1}&gt;0 $ ，故 $ y_2&gt;\frac{y_3-y_1}{x_3-x_1} x_2+\frac{x_3 y_1-x_1 y_3}{x_3-x_1} $ ，所以 $ (x_2,y_2 ) $ 一定不在下凸包内。</p><p>思路很清晰了吧？</p><h3 id="简简单单的代码"><a href="#简简单单的代码" class="headerlink" title="简简单单的代码"></a>简简单单的代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;using namespace std;const int N &#x3D; 5e4 + 5;int n, L, C, Qt[N], h &#x3D; 1, t;ll sum[N], f[N], Qx[N], Qy[N];il ll sq(ll x) &#123;return x * x;&#125;il double sl(ll x1, ll y1, ll x2, ll y2) &#123;return (double) (y1 - y2) &#x2F; (x1 - x2);&#125;int main() &#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;L, &amp;C);sum[1] &#x3D; C; f[1] &#x3D; sq(C - L);Qt[++t] &#x3D; 0; Qx[t] &#x3D; L + 1; Qy[t] &#x3D; sq(Qx[t]);Qt[++t] &#x3D; 1; Qx[t] &#x3D; L + 2 + C; Qy[t] &#x3D; f[1] + sq(Qx[t]);for(int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123;scanf(&quot;%d&quot;, &amp;C);sum[i] &#x3D; sum[i - 1] + C;double slope &#x3D; (i + sum[i]) &lt;&lt; 1;while(h &lt; t &amp;&amp; sl(Qx[h], Qy[h], Qx[h + 1], Qy[h + 1]) &lt; slope) ++h;f[i] &#x3D; f[Qt[h]] + sq(i - Qt[h] - 1 + sum[i] - sum[Qt[h]] - L);ll X &#x3D; i + sum[i] + L + 1, Y &#x3D; f[i] + sq(X);while(h &lt; t &amp;&amp; sl(Qx[t], Qy[t], Qx[t - 1], Qy[t - 1]) &gt;&#x3D; sl(Qx[t], Qy[t], X, Y)) --t; Qt[++t] &#x3D; i; Qx[t] &#x3D; X, Qy[t] &#x3D; Y;&#125;printf(&quot;%lld\n&quot;, f[n]);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h2><p>若 $ C_k $ 可以小于0呢？又该怎么做？</p><p>这个我们一眼就能看穿这玩意<strong>不满足单调性</strong>。</p><p>假如说考试的时候你不会证斜率的点或者决策有/没有单调性怎么办？</p><p>有两种方法。第一种是打表，多打几组。</p><p>第二种是不管三七二十一直接上不满足单调性时的做法。反正满足单调性的时候不满足单调性时的做法也能用。</p><p>不满足单调性的做法：</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>我们用 $ dc(l, r) $ 表示计算 $ [l, r] $ 中的 $ dp_i $ 。</p><p>对于左半边，我们先用 $ dc(l, mid) $ 算出 $ [l, mid] $ 中的 $ dp_i $ 。然后我们就知道了所有的决策点，那么就可以建凸包。然后我们用这个凸包去更新 $ [mid, r] $ 中的 $ dp_i $ 。这时的凸包是固定的，所以我们可以把 $ [mid, r] $ 的查询斜率排序，然后用单调队列维护。当然也可以直接在凸包上二分。</p><p>对于 $ [mid, r] $ 中的每个 $ dp_i $ ，如果它的最优决策点在 $ [1, mid] $ ，则上一步已经更新完，如果它的最优决策点不在 $ [l, mid] $ 我们也不需要 $ [l, mid] $ 的凸包。所以我们可以直接把左边的凸包抛掉，用 $ dc(mid + 1, r) $ 计算之后的 $ dp_i $ 。</p><p> $ T(n)=2T(\frac{n}{2})+O(n\log n))=O(n\log^2n) $ </p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;int n, h[100005], w[100005], pre[100005];long long dp[100005], sum[100005];struct Point &#123;long long x, y;int id;Point(long long _x, long long _y, int _id): x(_x), y(_y), id(_id) &#123;&#125;double operator&#x2F; (const Point &amp;p) const &#123; return (double) (y - p.y) &#x2F; (x - p.x); &#125;&#125;;long long min(long long a, long long b) &#123; return a &lt; b ? a : b; &#125;void cdq(int l, int r) &#123;while (l !&#x3D; r) &#123;std::vector&lt;Point&gt; Q, temp;int mid &#x3D; (l + r) &gt;&gt; 1;cdq(l, mid);for (int i &#x3D; l; i &lt;&#x3D; mid; ++i)temp.push_back(Point(h[i], dp[i] + (long long) h[i] * h[i] - sum[i], i));std::sort(temp.begin(), temp.end(), [] (const Point &amp;p1, const Point &amp;p2) &#123;return p1.x &#x3D;&#x3D; p2.x ? p1.y &lt; p2.y : p1.x &lt; p2.x;&#125;);Q.push_back(temp[0]); int _size &#x3D; 0;for (int i &#x3D; 1; i &lt; (int) temp.size(); ++i) &#123;if (Q[_size].x &#x3D;&#x3D; temp[i].x) continue;while (_size &amp;&amp; Q[_size] &#x2F; Q[_size - 1] &gt; Q[_size] &#x2F; temp[i]) Q.pop_back(), --_size;Q.push_back(temp[i]); ++_size;&#125;for (int i &#x3D; r; i &gt; mid; --i) &#123;int l &#x3D; 1, r &#x3D; Q.size() - 1, sl &#x3D; h[i] &lt;&lt; 1;while (l &lt;&#x3D; r) &#123;int mid &#x3D; (l + r) &gt;&gt; 1;if (Q[mid] &#x2F; Q[mid - 1] &gt; sl) r &#x3D; mid - 1;else l &#x3D; mid + 1;&#125;int k &#x3D; Q[r].id;dp[i] &#x3D; min(dp[i], dp[k] + (long long) (h[i] - h[k]) * (h[i] - h[k]) + sum[i - 1] - sum[k]);&#125;l &#x3D; mid + 1;&#125;&#125;int main() &#123;scanf(&quot;%d&quot;, &amp;n);for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, h + i);for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, w + i), sum[i] &#x3D; sum[i - 1] + w[i];memset(dp, 0x3f, sizeof dp); dp[1] &#x3D; 0;cdq(1, n); printf(&quot;%lld\n&quot;, dp[n]);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>思路很简洁，一说就懂，一写就废</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;inline unsigned rand() &#123;static unsigned seed &#x3D; 19260817;return (seed &#x3D; seed * 1279u + 10001279u) ^&#x3D; (seed &gt;&gt; 7);&#125;struct Point &#123;long long x, y;int id;Point(long long _x, long long _y, int _id): x(_x), y(_y), id(_id) &#123;&#125;Point() &#123;&#125;double operator&#x2F; (const Point &amp;p) const &#123; return (double) (y - p.y) &#x2F; (x - p.x); &#125;&#125;;struct Treap &#123;struct node &#123;int ls, rs, size;Point p;double lp, rp;unsigned key;&#125; tr[100005];int cnt, root;inline int new_node(const Point &amp;p) &#123;tr[++cnt].p &#x3D; p;tr[cnt].key &#x3D; rand();tr[cnt].size &#x3D; 1;return cnt;&#125;inline void push_up(int k) &#123; if (k) tr[k].size &#x3D; tr[tr[k].ls].size + tr[tr[k].rs].size + 1; &#125;void rotate_left(int &amp;k) &#123;int old_k &#x3D; k;k &#x3D; tr[k].rs;tr[old_k].rs &#x3D; tr[k].ls;tr[k].ls &#x3D; old_k;push_up(old_k);push_up(k);&#125;void rotate_right(int &amp;k) &#123;int old_k &#x3D; k;k &#x3D; tr[k].ls;tr[old_k].ls &#x3D; tr[k].rs;tr[k].rs &#x3D; old_k;push_up(old_k);push_up(k);&#125;int insert(int &amp;k, const Point &amp;v) &#123;int tmp;if (!k) &#123; return k &#x3D; new_node(v); &#125;if (v.x &lt; tr[k].p.x) &#123;if (tmp &#x3D; insert(tr[k].ls, v)) &#123;if (tr[k].key &gt; tr[tr[k].ls].key) rotate_right(k);push_up(k);return tmp;&#125; else return 0;&#125; else if (v.x &gt; tr[k].p.x) &#123;if (tmp &#x3D; insert(tr[k].rs, v)) &#123;if (tr[k].key &gt; tr[tr[k].rs].key) rotate_left(k);push_up(k);return tmp;&#125; else return 0;&#125; else &#123;if (tr[k].p.y &lt; v.y) return 0;tr[k].p.y &#x3D; v.y; tr[k].p.id &#x3D; v.id; return k;&#125;&#125;void remove(int &amp;k, long long x) &#123;if (!k) return;if (tr[k].p.x &#x3D;&#x3D; x) &#123;if (tr[k].ls &amp;&amp; tr[k].rs) &#123;if (tr[tr[k].ls].key &lt; tr[tr[k].rs].key) rotate_right(k), remove(tr[k].rs, x);else rotate_left(k), remove(tr[k].ls, x);&#125; else k &#x3D; tr[k].ls | tr[k].rs;&#125; else if (x &lt; tr[k].p.x) remove(tr[k].ls, x);else remove(tr[k].rs, x);push_up(k);&#125;int rank(long long x) &#123;int rnk &#x3D; 0, k &#x3D; root;while (k) &#123;if (x &lt;&#x3D; tr[k].p.x) k &#x3D; tr[k].ls;else rnk +&#x3D; tr[tr[k].ls].size + 1, k &#x3D; tr[k].rs;&#125;return rnk + 1;&#125;int value(int x) &#123;if (x &gt; tr[root].size || x &lt;&#x3D; 0) return -1;int k &#x3D; root;while (k) &#123;if (x &lt;&#x3D; tr[tr[k].ls].size) k &#x3D; tr[k].ls;else if (x &#x3D;&#x3D; tr[tr[k].ls].size + 1) return k;else x -&#x3D; tr[tr[k].ls].size + 1, k &#x3D; tr[k].rs;&#125;return -1;&#125;int prev(long long v) &#123; return value(rank(v) - 1); &#125;int next(long long v) &#123; return value(rank(v + 1)); &#125; void insert_hull(const Point &amp;point) &#123;int k &#x3D; insert(root, point);if (!k) return;int k1 &#x3D; prev(point.x);if (k1 !&#x3D; -1) &#123;while (tr[k1].lp &gt; point &#x2F; tr[k1].p) remove(root, tr[k1].p.x), k1 &#x3D; prev(tr[k1].p.x);tr[k].lp &#x3D; tr[k1].rp &#x3D; point &#x2F; tr[k1].p;&#125; else tr[k].lp &#x3D; -1e30;int k2 &#x3D; next(point.x);if (k2 !&#x3D; -1) &#123;while (point &#x2F; tr[k2].p &gt; tr[k2].rp)remove(root, tr[k2].p.x), k2 &#x3D; next(tr[k2].p.x);tr[k].rp &#x3D; tr[k2].lp &#x3D; tr[k2].p &#x2F; point;&#125; else tr[k].rp &#x3D; 1e30;if (tr[k].lp &gt; tr[k].rp) &#123;remove(root, tr[k].p.x);tr[k1].rp &#x3D; tr[k2].lp &#x3D; tr[k1].p &#x2F; tr[k2].p;&#125;&#125;int query_hull(long long slope) &#123;int k &#x3D; root;while (k) &#123;if (tr[k].lp &lt;&#x3D; slope &amp;&amp; slope &lt;&#x3D; tr[k].rp) return tr[k].p.id;else if (slope &lt; tr[k].lp) k &#x3D; tr[k].ls;else k &#x3D; tr[k].rs;&#125;return -1;&#125;&#125; treap;int n, w[100005], h[100005];long long sum[100005], dp[100005];long long min(long long a, long long b) &#123; return a &lt; b ? a : b; &#125;int main() &#123;scanf(&quot;%d&quot;, &amp;n);for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, h + i);for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, w + i), sum[i] &#x3D; sum[i - 1] + w[i];memset(dp, 0x3f, sizeof dp); dp[1] &#x3D; 0;treap.new_node(Point(h[1], (long long) h[1] * h[1] - w[1], 1));treap.root &#x3D; 1; treap.tr[1].lp &#x3D; -1e30; treap.tr[1].rp &#x3D; 1e30;for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123;int j &#x3D; treap.query_hull(h[i] &lt;&lt; 1);dp[i] &#x3D; min(dp[i], dp[j] + (long long) (h[i] - h[j]) * (h[i] - h[j]) + sum[i - 1] - sum[j]);treap.insert_hull(Point(h[i], dp[i] + (long long) h[i] * h[i] - sum[i], i));&#125;printf(&quot;%lld&quot;, dp[n]);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二进制分组"><a href="#二进制分组" class="headerlink" title="二进制分组"></a>二进制分组</h3><p>我们将所有的点分成若干组，第 $ i $ 组大小为 $ 2^i $ ，显然组数不超过 $ O(\log n) $ 。我们维护每组的凸包。</p><p>插入一个点时，若没有第0组，则将它作为第0组，否则将它和第0组合并。这样我们得到了第1组。接下来如果有第1组，则再将它与第1组合并得到第2组……类似二进制+1的过程。</p><p>查询在每一组分别二分，取最大即可。</p><p>关于时间复杂度：</p><p>显然每个点最多被合并 $ O(\log ⁡n) $ 次。我们合并两个包含 $ O(n) $ 个节点的凸包的时间复杂度是 $ O(n) $ 的，故均摊到每个点上合并的时间复杂度是 $ O(1) $ ，又因为共有 $ O(n) $ 个点，所以总时间复杂度 $ O(n\log⁡ n) $ 。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;vector&gt;int n, h[100005], w[100005];long long dp[100005], sum[100005];struct Point &#123;long long x, y;int id;Point(long long _x, long long _y, int _id): x(_x), y(_y), id(_id) &#123;&#125;double operator&#x2F; (const Point &amp;p) const &#123; return (double) (y - p.y) &#x2F; (x - p.x); &#125;&#125;;struct ConvexHull &#123;std::vector&lt;Point&gt; p;void merge(ConvexHull &amp;h) &#123;std::vector&lt;Point&gt; possible_conv;int i &#x3D; 0, j &#x3D; 0;while (i &lt; (int) p.size() &amp;&amp; j &lt; (int) h.p.size())if (p[i].x &#x3D;&#x3D; h.p[j].x) &#123;if (p[i].y &lt; h.p[j].y) possible_conv.push_back(p[i]);else possible_conv.push_back(h.p[j]);++i; ++j;&#125; else if (p[i].x &lt; h.p[j].x) possible_conv.push_back(p[i]), ++i;else possible_conv.push_back(h.p[j]), ++j;while (i &lt; (int) p.size()) possible_conv.push_back(p[i]), ++i;while (j &lt; (int) h.p.size()) possible_conv.push_back(h.p[j]), ++j;p.clear(); p.push_back(possible_conv[0]);int _size &#x3D; 0;for (int i &#x3D; 1; i &lt; (int) possible_conv.size(); ++i) &#123;while (_size &amp;&amp; p[_size] &#x2F; p[_size - 1] &gt; p[_size] &#x2F; possible_conv[i]) p.pop_back(), --_size;p.push_back(possible_conv[i]); ++_size;&#125;h.p.clear();&#125;int query(long long k) &#123;int l &#x3D; 1, r &#x3D; p.size() - 1;while (l &lt;&#x3D; r) &#123;int mid &#x3D; (l + r) &gt;&gt; 1;if (p[mid] &#x2F; p[mid - 1] &gt; k) r &#x3D; mid - 1;else l &#x3D; mid + 1;&#125;return p[r].id;&#125;ConvexHull() &#123;&#125;ConvexHull(const Point &amp;P) &#123; p.push_back(P); &#125;&#125; conv[17];long long min(long long a, long long b) &#123; return a &lt; b ? a : b; &#125;int main() &#123;scanf(&quot;%d&quot;, &amp;n);for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, h + i);for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) scanf(&quot;%d&quot;, w + i), sum[i] &#x3D; sum[i - 1] + w[i];memset(dp, 0x3f, sizeof dp); dp[1] &#x3D; 0;conv[0] &#x3D; ConvexHull(Point(h[1], (long long) h[1] * h[1] - w[1], 1));for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123;for (int j &#x3D; 0; j &lt; 17; ++j) &#123;if (conv[j].p.empty()) continue;int k &#x3D; conv[j].query(h[i] &lt;&lt; 1);dp[i] &#x3D; min(dp[i], dp[k] + (long long) (h[i] - h[k]) * (h[i] - h[k]) + sum[i - 1] - sum[k]);&#125;ConvexHull cv(Point(h[i], dp[i] + (long long) h[i] * h[i] - sum[i], i));for (int j &#x3D; 0; j &lt; 17; ++j) &#123;if (conv[j].p.empty()) &#123;conv[j].p &#x3D; cv.p;break;&#125;cv.merge(conv[j]);&#125;&#125;printf(&quot;%lld&quot;, dp[n]);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 $ dp $ 的最小/最大化问题中，将转移方程分成四部分：一部分与 $ i, j $ 都无关，一部分只与 $ j $ 有关，一部分只与 $ i $ 有关，还有一部分和 $ i, j $ 都有关。如果它能写成  $ y=kx+b $  的形式，我们就可以维护一个凸包，来进行状态的转移。</p><p><strong>怎么样，你学会(废)了吗</strong></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><blockquote><p>此处放出你谷的链接</p></blockquote><ul><li><a href="https://www.luogu.com.cn/problem/P4655">P4655 / loj 2483 Building Bridges</a></li><li><a href="https://www.luogu.com.cn/problem/P5017">P5017 / loj 3007 [NOIP2018 普及组] 摆渡车</a></li><li><a href="https://www.luogu.com.cn/problem/P4027">P4027 / loj 2353 [NOI2007] 货币兑换</a></li><li><a href="https://www.luogu.com.cn/problem/P3571">P3571 [POI2014] SUP-Supercomputer</a></li><li><a href="https://www.luogu.com.cn/problem/CF311B">CF311B Cats Transport</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;斜率优化-dp&quot;&gt;&lt;a href=&quot;#斜率优化-dp&quot; class=&quot;headerlink&quot; title=&quot;斜率优化 $ dp $&quot;&gt;&lt;/a&gt;斜率优化 $ dp $&lt;/h1&gt;&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="教程" scheme="http://www.honahec.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="http://www.honahec.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>矩阵</title>
    <link href="http://www.honahec.com/ju-zhen/"/>
    <id>http://www.honahec.com/ju-zhen/</id>
    <published>2021-06-25T13:52:15.000Z</published>
    <updated>2021-09-17T12:45:11.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="矩阵-Matrix-定义"><a href="#矩阵-Matrix-定义" class="headerlink" title="矩阵(Matrix)定义"></a>矩阵(Matrix)定义</h2><p>一个  $ n\times m $  的矩阵是一个由  $ n $  行  $ m $  列元素排成的矩形阵列。矩阵里的元素可以是数字符号或者数学式。</p><p>形如 $ \left(\begin{matrix}a&amp;b\\c&amp;d\end{matrix}\right) $ 的数表称为<strong>二阶矩阵</strong>，它由二行二列组成，其中 $ a,b,c,d $ 称为这个矩阵的元素。</p><p>形如 $ \left(\begin{matrix}x_1\\x_2\end{matrix}\right) $ 的有序对称为<strong>列向量(Column Vector)</strong></p><h2 id="矩阵加法"><a href="#矩阵加法" class="headerlink" title="矩阵加法"></a>矩阵加法</h2><p>矩阵的加法非常简单</p><p>对，就是你想的那样</p><script type="math/tex; mode=display">\left(\begin{matrix}a_{1,1}&a_{1,2}&\cdots&a_{1,m}\\a_{2,1}&a_{2,1}&\cdots&a_{2,m}\\\vdots&\vdots&&\vdots\\a_{n,1}&a_{n,2}&\cdots&a_{n,m}\end{matrix}\right)\pm\left(\begin{matrix}b_{1,1}&b_{1,2}&\cdots&b_{1,m}\\b_{2,1}&b_{2,1}&\cdots&b_{2,m}\\\vdots&\vdots&&\vdots\\b_{n,1}&b_{n,2}&\cdots&b_{n,m}\end{matrix}\right)=\left(\begin{matrix}a_{1,1}\pm b_{1,1}&a_{1,2}\pm b_{1,2}&\cdots&a_{1,m}\pm b_{1,m}\\a_{2,1}\pm b_{2,1}&a_{2,1}\pm b_{2,2}&\cdots&a_{2,m}\pm b_{2, m}\\\vdots&\vdots&&\vdots\\a_{n,1}\pm b_{n,1}&a_{n,1}\pm b_{n,2}&\cdots&a_{n,m}\pm b_{n,m}\end{matrix}\right)</script><p>注意：两个矩阵必须为<strong>同型矩阵</strong>(即必须都是  $ n\times m $  的矩阵)才能相加</p><p>并且，矩阵加减法<strong>满足</strong>交换律和结合律(即 $ A+B=B+A $ ， $ (A+B)+C=A+(B+C) $ )</p><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>矩阵乘法<strong>稍有</strong>不同</p><p>嗯，真的只有一点不同</p><p>如果有矩阵  $ A $  大小为  $ n\times m $  ，矩阵  $ B $  大小为  $ m\times s $  ，相乘为矩阵  $ C $ ，矩阵  $ C $  的大小一定为  $ n\times s $ </p><p>矩阵乘法遵循  $ C=\sum_{k=1}^{m}a_{i,k}b_{k,j} $ </p><p>嗯，只有一点</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>设</p><script type="math/tex; mode=display">\begin{align}A&=\left(\begin{matrix}a&b\\c&d\end{matrix}\right)\\\\B&=\left(\begin{matrix}x_1\\x_2\end{matrix}\right)\\\end{align}</script><p>则</p><script type="math/tex; mode=display">\begin{align}C=AB&=\left(\begin{matrix}ax_1+bx_2\\cx_1+dx_2\end{matrix}\right)\\\end{align}</script><p>称为二阶矩阵  $ A $  与平面向量  $ B $  的乘积，记为  $ AB=C $ </p><h2 id="利用矩阵求斐波那契-Fibonacci-数列"><a href="#利用矩阵求斐波那契-Fibonacci-数列" class="headerlink" title="利用矩阵求斐波那契(Fibonacci)数列"></a>利用矩阵求斐波那契(Fibonacci)数列</h2><p>众所周知，斐波那契数列从第三项开始，每一项都是前两项之和</p><p>即 $ F_n=F_{n-1}+F_{n-2},n\geq3 $ </p><p>特别的 $ F_0=0,F_1=F_2=1 $ </p><p>把斐波那契数列中相邻的两项(  $ F_n $  和  $ F_{n-1} $  )写成一个 $ 2\times1 $ 的矩阵</p><script type="math/tex; mode=display">\begin{align}&=\left(\begin{matrix}F_n\\ F_{n-1}\end{matrix}\right)\\\\&=\left(\begin{matrix}F_{n-1}+F_{n-2}\\ F_{n-1}\end{matrix}\right)\\\\&=\left(\begin{matrix}1\times F_{n-1}+1\times F_{n-2}\\ 1\times F_{n-1}+0\times F_{n-2}\end{matrix}\right)\\\\&=\left(\begin{matrix}1&1\\ 1&0\end{matrix}\right)\times \left(\begin{matrix}F_{n-1}\\ F_{n-2}\end{matrix}\right)\\\\&=\left(\begin{matrix}1&1\\ 1&0\end{matrix}\right)^{n-1}\times \left(\begin{matrix}F_1\\ F_0\end{matrix}\right)\\\\&=\left(\begin{matrix}1&1\\ 1&0\end{matrix}\right)^{n-1}\times \left(\begin{matrix}1\\ 0\end{matrix}\right)\end{align}</script><p>求  $ F_n $  等同于求二阶矩阵的  $ n-1 $  次方，结果取矩阵第一行元素。</p><p>问题转换为二阶矩阵的  $ n $  次幂</p><h3 id="求二阶矩阵的-N-次幂"><a href="#求二阶矩阵的-N-次幂" class="headerlink" title="求二阶矩阵的  $ N $  次幂"></a>求二阶矩阵的  $ N $  次幂</h3><p>这里可以回顾一下<a href="#toc-heading-3">矩阵乘法</a></p><p><strong>假设计算矩阵  $ A $  的  $ N $  次幂</strong></p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>二阶矩阵的乘法满足结合律</p><p>设 $ A,B,C $ 都是任意的二阶矩阵</p><p>则 $ A(BC)=(AB)C $ </p><blockquote><p>不在此证明</p></blockquote><p>设 $ n=N\div 2 $  (结果向下取整)</p><p>若  $ N\in 2k $  则  $ A^N=A^n\times A^n $ </p><p>若  $ N\in 2k+1 $  则  $ A^N=A^n\times A^n\times A $ </p><blockquote><p>这样可以减少计算次数，自行思考原因</p></blockquote><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>以计算  $ A^6 $  为例</p><p>例如 $ 6_{(10)}=110_{(2)} $ </p><p>则  $ A^6=A^4\times A^2 $ </p><p><img src="https://z3.ax1x.com/2021/06/15/2qY2uV.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/06/15/2qY2uV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="二进制位"></p><p>上图显示二进制与幂的指数关系</p><p>二进位为1需要乘，为0不需要乘</p><p>再例如 $ 7_{(10)}=111_{(2)} $ </p><p>则 $ A^7=A^4\times A^2\times A^1 $ </p><p>先随随便便写一个求快速幂的代码(<del>相信大家都会写吧</del></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int qpow(int a, int k) &#123;    int res &#x3D; 1;    while(k) &#123;        if(a &amp; 1) res *&#x3D; a;        k &gt;&gt;&#x3D; 1;        a *&#x3D; a;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么到底怎么用矩阵求斐波那契数列呢？</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;struct Matrix &#123;long long fib[2][2];Matrix() &#123;memset(fib, 0, sizeof fib);&#125;&#125;;Matrix qmul(Matrix &amp;a, Matrix &amp;b) &#123;Matrix c;for(int i &#x3D; 0; i &lt; 2; ++i) &#123;for(int j &#x3D; 0; j &lt; 2; ++j) &#123;for(int k &#x3D; 0; k &lt; 2; ++k) &#123;c.fib[i][j] +&#x3D; a.fib[i][k] * b.fib[k][j];&#125;&#125;&#125;return c;&#125;Matrix qpow(Matrix a, long long k) &#123;Matrix ans;ans.fib[0][0] &#x3D; ans.fib[1][1] &#x3D; 1;while(k) &#123;if(k &amp; 1) ans &#x3D; qmul(ans, a);a &#x3D; qmul(a, a);k &gt;&gt;&#x3D; 1;&#125;return ans;&#125;int main() &#123;long long n;Matrix a, b;scanf(&quot;%lld&quot;, &amp;n);a.fib[0][0] &#x3D; a.fib[0][1] &#x3D; a.fib[1][0] &#x3D; 1;b &#x3D; qpow(a, n);printf(&quot;%lld\n&quot;, b.fib[0][1]);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你学 <del>废</del> 会了吗</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;矩阵&quot;&gt;&lt;a href=&quot;#矩阵&quot; class=&quot;headerlink&quot; title=&quot;矩阵&quot;&gt;&lt;/a&gt;矩阵&lt;/h1&gt;&lt;h2 id=&quot;矩阵-Matrix-定义&quot;&gt;&lt;a href=&quot;#矩阵-Matrix-定义&quot; class=&quot;headerlink&quot; title=&quot;矩</summary>
      
    
    
    
    <category term="教程" scheme="http://www.honahec.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="http://www.honahec.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>打鼹鼠</title>
    <link href="http://www.honahec.com/da-yan-shu/"/>
    <id>http://www.honahec.com/da-yan-shu/</id>
    <published>2021-06-25T13:51:07.000Z</published>
    <updated>2021-09-17T12:45:11.487Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P2285">P2285 打鼹鼠</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很明显，这是一道 $ dp $ 题，因为标签已经告诉我们了（不是</p><p>怎么 $ dp $ 呢？</p><p>棋盘？三维必炸啊，<del>二维本蒟蒻不会</del></p><p>时间？<del>更离谱了</del></p><p>所以就只能从鼹鼠下手了</p><p>设 $ dp_i $ 为到第 $ i $ 只鼹鼠时最多能打到几只</p><p>因为我们要守株待兔（鼠），所以初始化 $ dp_i=1 $ </p><p>若两鼹鼠之间的<a href="https://baike.baidu.com/item/曼哈顿距离/743092?fr=aladdin">曼哈顿距离</a>小于出现时间差</p><p>此时转移方程为 $ dp_i=min(dp[i],dp[j]+1) $ </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cmath&gt;#define fo(i,x,y) for(register int i&#x3D;x;i&lt;&#x3D;y;++i)#define go(i,x,y) for(register int i&#x3D;x;i&gt;&#x3D;y;--i)#define INF 0x3f3f3f3f#define il inline#define ll long long#define ull unsigned long longusing namespace std;const int N &#x3D; 1005, M &#x3D; 10005;int n, m, dp[M], ans;struct NODE &#123;int time, x, y;&#125;node[M];il int max(const int &amp;a, const int &amp;b) &#123;return a &gt; b ? a : b;&#125;int main() &#123;scanf(&quot;%d%d&quot;, &amp;n, &amp;m);fo(i, 1, m) scanf(&quot;%d%d%d&quot;, &amp;node[i].time, &amp;node[i].x, &amp;node[i].y), dp[i] &#x3D; 1;fo(i, 1, m) &#123;fo(j, 1, i - 1) &#123;if(abs(node[i].x - node[j].x) + abs(node[i].y - node[j].y) &lt;&#x3D; abs(node[i].time - node[j].time)) &#123;dp[i] &#x3D; max(dp[i], dp[j] + 1);&#125;&#125;&#125;fo(i, 1, m) ans &#x3D; max(ans, dp[i]);printf(&quot;%d\n&quot;, ans);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2285&quot;&gt;P2285 打鼹鼠&lt;/a&gt;</summary>
      
    
    
    
    <category term="题解" scheme="http://www.honahec.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://www.honahec.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Radio Contact G</title>
    <link href="http://www.honahec.com/radio-contact-g/"/>
    <id>http://www.honahec.com/radio-contact-g/</id>
    <published>2021-06-25T13:50:26.000Z</published>
    <updated>2021-09-17T12:45:11.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.com.cn/problem/P3133">P3133 Radio Contact G</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p> $ dp $ 题</p><p>设 $ dp_{i,j} $ 为Farmer John走到第i步，Bessie走到第j步需要的最小能量</p><p>很容易得到转移方程 $ f_{i,j}=min(f_{i-1,j},f_{i,j-1},f_{i-1,j-1})+dist $ </p><p>其中 $ dist $ 为Farmer John在第i步，Bessie在第j步时他们<a href="https://baike.baidu.com/item/欧几里得度量/1274107?fromtitle=欧几里得距离&amp;fromid=2701459">欧几里得距离</a>的平方</p><p>即 $ (x_1-x_2)^2-(y_1-y_2)^2 $ </p><h3 id="注意一下初始化："><a href="#注意一下初始化：" class="headerlink" title="注意一下初始化："></a>注意一下初始化：</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">f[i][0] &#x3D; f[i - 1][0] + dist;f[0][i] &#x3D; f[i - 1][0] + dist;f[0][0] &#x3D; 0; &#x2F;&#x2F;初始位置不消耗能量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后这道题就愉快的AC了</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#define fo(i,x,y) for(register int i&#x3D;x;i&lt;&#x3D;y;++i)#define go(i,x,y) for(register int i&#x3D;x;i&gt;&#x3D;y;--i)#define INF 0x3f3f3f3f#define il inline#define ll long long#define ull unsigned long longusing namespace std;const int N &#x3D; 1005;int n, m, fx, fy, bx, by;char fs[N], bs[N];int f[N][N];il int min(const int &amp;a, const int &amp;b) &#123;return a &lt; b ? a : b;&#125;il void move(int &amp;x, int &amp;y, const char &amp;t) &#123;switch(t) &#123;case &#39;N&#39;: ++y; break;case &#39;S&#39;: --y; break;case &#39;E&#39;: ++x; break;case &#39;W&#39;: --x; break;&#125;&#125;il int dist(const int &amp;x1, const int &amp;y1, const int &amp;x2, const int &amp;y2) &#123;return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);&#125;int main() &#123;scanf(&quot;%d%d%d%d%d%d%s%s&quot;, &amp;n, &amp;m, &amp;fx, &amp;fy, &amp;bx, &amp;by, fs + 1, bs + 1);int lenf &#x3D; strlen(fs + 1), lenb &#x3D; strlen(bs + 1);int tx1 &#x3D; fx, ty1 &#x3D; fy, tx2 &#x3D; bx, ty2 &#x3D; by;fo(i, 1, lenf) &#123;move(tx1, ty1, fs[i]);f[i][0] &#x3D; f[i - 1][0] + dist(tx1, ty1, bx, by);&#125;fo(i, 1, lenb) &#123;move(tx2, ty2, bs[i]);f[0][i] &#x3D; f[0][i - 1] + dist(fx, fy, tx2, ty2);&#125;&#x2F;&#x2F;初始化tx1 &#x3D; fx, ty1 &#x3D; fy;fo(i, 1, lenf) &#123;tx2 &#x3D; bx, ty2 &#x3D; by;move(tx1, ty1, fs[i]);fo(j, 1, lenb) &#123;move(tx2, ty2, bs[j]);f[i][j] &#x3D; min(f[i - 1][j], min(f[i][j - 1], f[i - 1][j - 1])) + dist(tx1, ty1, tx2, ty2);&#125;&#125;printf(&quot;%lld\n&quot;, f[lenf][lenb]);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3133&quot;&gt;P3133 Radio C</summary>
      
    
    
    
    <category term="题解" scheme="http://www.honahec.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://www.honahec.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>有理数取余</title>
    <link href="http://www.honahec.com/you-li-shu-qu-yu/"/>
    <id>http://www.honahec.com/you-li-shu-qu-yu/</id>
    <published>2021-06-25T13:49:03.000Z</published>
    <updated>2021-09-17T12:45:11.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P2613">P2613 【模板】有理数取余</a></p><h3 id="题目非常简单易懂"><a href="#题目非常简单易懂" class="headerlink" title="题目非常简单易懂"></a>题目非常简单易懂</h3><p>给出一个有理数 $ c=\frac{a}{b} $，求 $ c\bmod19260817 $  的值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到这道题时</p><ul><li>第一眼：好像很简单啊</li><li>第二眼：$ a,b\leq10^{10001} $？！！</li><li>第三眼：卧槽这啥玩意？！！</li></ul><p>要做这道题，我们来介绍一个新的东西<del>（主要是本蒟蒻不会<code>exgcd</code>（欧几里得扩展）</del></p><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><blockquote><p>P 是一个质数</p></blockquote><p>令 $ b’ $ 为 $ b $ 的逆元，那么有$ b\times b’\equiv1\,(mod\,P) $</p><p>有 $ \frac{a}{b}\equiv\frac{a}{b}\times1\equiv\frac{a}{b}\times(b\times b’)\equiv a\times b’\,(mod\,P) $ </p><p>显然可以看出 $ b’ $ 的值为 $ \frac{1}{b} $ </p><p>但是除以 $ b $ 与乘以 $ \frac{1}{b} $ 是一样的啊，怎么办呢？</p><h3 id="费马小定理闪亮登场"><a href="#费马小定理闪亮登场" class="headerlink" title="费马小定理闪亮登场"></a>费马小定理闪亮登场</h3><p><strong>定理内容：如果 $ p$  是一个质数，而整数 $ a$  不是 $ p$  的倍数，则有$ a^{p-1}\equiv1\,(mod\,p) $</strong></p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p><strong>你可以选择<a href="#toc-heading-7">跳过</a>这部分</strong></p><blockquote><p> 证明部分 $ p $ 是一个质数</p></blockquote><h5 id="第一个证明"><a href="#第一个证明" class="headerlink" title="第一个证明"></a>第一个证明</h5><p>首先我们考虑一个前置定理：</p><p>若$ gcd(c,p)=1 $，且$ ac\equiv bc\,(mod\,p) $，那么有$ a\equiv b\,(mod\,p) $</p><p><strong>证：</strong></p><script type="math/tex; mode=display">\begin{align}&\because ac\equiv bc\,(mod\,p)\\&\therefore (a-b)c\equiv 0\,(mod\,p)\\&\therefore (a-b)c\,是\,p\,的整数倍\\又&\because gcd(c,p)=1\\&\therefore a-b\equiv0\,(mod\,p)\\&即a\equiv b\,(mod\,p)\end{align}</script><p><strong>证毕</strong></p><h5 id="第二个证明"><a href="#第二个证明" class="headerlink" title="第二个证明"></a>第二个证明</h5><p>然后我们进入正题，假设有正整数$ a(a&lt;p) $ 满足条件$ gcd(a,p)=1 $，那么我们将 $ a $ 乘上 $ 1\thicksim p-1 $ 后可以构成一个 $ mod\,p $ 的<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E5%89%A9%E4%BD%99%E7%B3%BB">完全剩余系</a></p><p><strong>证：</strong></p><script type="math/tex; mode=display">\begin{align}&假设存在xa\equiv ya\,(mod\,p),且x\neq y\\&\because gcd(a,p)=1\\&\therefore 原式成立当且仅当x\equiv y\,(mod\,p)\\又&\because x,y\in [1,p-1]\\&\therefore x\equiv y\,(mod\,p)当且仅当x=y,与已知条件矛盾\\&\therefore 假设不成立，原命题成立\end{align}</script><p><strong>证毕</strong></p><h5 id="第三个证明"><a href="#第三个证明" class="headerlink" title="第三个证明"></a>第三个证明</h5><p>接下来证明 $ a^{p-1}\equiv1\,(mod\,p) $ </p><p><strong>证：</strong></p><script type="math/tex; mode=display">\begin{align}&\because 1,2,\cdots,p-1是\,mod\,p\,的完全剩余系\\&\therefore有1\times2\times\cdots\times p-1\equiv a\times2a\times\cdots\times (p-1)a\,(mod\,p)\\&即 (p-1)!\equiv (p-1)!\times a^{p-1}\,(mod\,p)\\又&\because p是质数\\&\therefore gcd((p-1)!,p)=1\\&\therefore a^{p-1}\equiv1\,(mod\,p)\end{align}</script><p><strong>证毕</strong></p><h4 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h4><p>根据费马小定理，显然 $ b’=b^{P-2} $ </p><p>什么？不显然吗？</p><script type="math/tex; mode=display">\begin{align}\because b'\times b&\equiv1\,(mod\,P)\\b^{P-1}&\equiv1\,(mod\,P)\\\therefore b'\times b&\equiv b^{P-1}\,(mod\,P)\\\therefore b'&=b^{P-2}\end{align}</script><p>那么 $ \frac{a}{b}=a\times b^{P-2} $ </p><p>然后我们就可以用快速幂轻松A掉这题了（$ ps$ ：虽然快速幂让我们不需要高精了，但<code>long long</code>还是要的</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;const int MOD &#x3D; 19260817;inline long long read() &#123;long long X &#x3D; 0, flag &#x3D; 1; char ch &#x3D; getchar();while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;) &#123;if(ch &#x3D;&#x3D; &#39;-&#39;) flag &#x3D; 0; ch&#x3D;getchar();&#125;while(ch &gt;&#x3D; &#39;0&#39; &amp;&amp; ch &lt;&#x3D; &#39;9&#39;) &#123;X &#x3D; (X * 10 + (ch ^ 48)) % MOD; ch &#x3D; getchar();&#125;return flag ? X : -X;&#125;long long a, b;long long QuickPow(long long x, long long y) &#123;long long ans &#x3D; 1, k &#x3D; MOD - 2;while(k) &#123;if(k &amp; 1) ans &#x3D; ans * x % MOD;x &#x3D; x * x % MOD;k &gt;&gt;&#x3D; 1;&#125;return ans * y % MOD;&#125;&#x2F;&#x2F;快速幂不建议这样写，还是用模板比较好int main() &#123;a &#x3D; read(); b &#x3D; read();if(b) printf(&quot;%lld\n&quot;, QuickPow(b, a));else printf(&quot;Angry!\n&quot;);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2613&quot;&gt;P2613 【模板】有理数</summary>
      
    
    
    
    <category term="题解" scheme="http://www.honahec.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://www.honahec.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.honahec.com/hello-world/"/>
    <id>http://www.honahec.com/hello-world/</id>
    <published>2021-06-25T13:38:19.000Z</published>
    <updated>2021-09-19T07:20:34.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hello-大家好啊"><a href="#Hello-大家好啊" class="headerlink" title="Hello 大家好啊"></a>Hello 大家好啊</h2><p>我是Honahec，一个蒟蒻</p><p>目前这个博客仍在建设中，如果您有任何想法都可以在<strong>上方的留言板</strong>中留言或者添加我的QQ，我会及时回复并采纳部分建议</p><p>如果您也想要建设一个属于自己的博客也可以联系我</p><p><strong>谢谢大家</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstdio&gt;int main() &#123;    printf(&quot;Hello World!\n&quot;);    return 114514; &#x2F;&#x2F;:)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hello-大家好啊&quot;&gt;&lt;a href=&quot;#Hello-大家好啊&quot; class=&quot;headerlink&quot; title=&quot;Hello 大家好啊&quot;&gt;&lt;/a&gt;Hello 大家好啊&lt;/h2&gt;&lt;p&gt;我是Honahec，一个蒟蒻&lt;/p&gt;
&lt;p&gt;目前这个博客仍在建设中，如果您有</summary>
      
    
    
    
    <category term="随便说说" scheme="http://www.honahec.com/categories/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/"/>
    
    
    <category term="摸鱼" scheme="http://www.honahec.com/tags/%E6%91%B8%E9%B1%BC/"/>
    
  </entry>
  
</feed>
